Repository: replifactory

File Tree:
└── old_version/replifactory_v7/vue/src/server/url_into_sheet.py
└── server/src/replifactory_server/create_experiment.py
└── server/src/replifactory_server/database.py
└── server/src/replifactory_server/database_models.py
└── server/src/replifactory_server/init_db.py
└── server/src/replifactory_server/models.py
└── server/src/replifactory_server/monitor.py
└── server/src/replifactory_server/routes.py
└── server/src/replifactory_server/server.py
└── server/src/replifactory_server/start_experiment.py
└── server/src/replifactory_server/start_server.py
└── simulation/examples/quick_start.py
└── simulation/examples/run_simulation.py
└── simulation/src/replifactory_simulation/__init__.py
└── simulation/src/replifactory_simulation/devices.py
└── simulation/src/replifactory_simulation/factory.py
└── simulation/src/replifactory_simulation/growth_model.py
└── simulation/src/replifactory_simulation/logging.py
└── simulation/src/replifactory_simulation/runner.py
└── simulation/src/replifactory_simulation/simulation_factory.py
└── simulation/tests/simple_test.py
└── ui/index.html
└── ui/pyproject.toml
└── ui/serve.py
└── ui/tests/.gitkeep

File Contents:

--- old_version/replifactory_v7/vue/src/server/url_into_sheet.py ---
import json
import time
import socket
import gspread
import requests
from oauth2client.service_account import ServiceAccountCredentials
import os


def get_sheet(spreadsheet_id, sheet_name):
    # use creds to create a client to interact with the Google Drive API
    scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']

    # relative to script dir
    script_dir = os.path.dirname(__file__)
    secrets_file = os.path.join(script_dir, '../../../secrets/googlekey.json')
    creds = ServiceAccountCredentials.from_json_keyfile_name(secrets_file, scope)
    client = gspread.authorize(creds)
    try:
        sheet = client.open_by_key(spreadsheet_id).worksheet(sheet_name)
    except gspread.exceptions.WorksheetNotFound:
        client.open_by_key(spreadsheet_id).add_worksheet(sheet_name, 100, 100)
        sheet = client.open_by_key(spreadsheet_id).worksheet(sheet_name)
    return sheet


def edit_hostname_sheet(spreadsheet_id, sheet_name):
    sheet = get_sheet(spreadsheet_id, sheet_name)
    # get current ip using dev.get_ip()
    url = get_ngrok_url()
    # Update the specified row with the given values
    sheet.update('A1', "IP")
    sheet.update('B1', url)
    sheet.update('A2', "last update")
    sheet.update('B2', time.ctime())

def edit_main_sheet(spreadsheet_id):
    sheet = get_sheet(spreadsheet_id, "main")
    # get current ip using dev.get_ip()
    url = get_ngrok_url()
    # Update the specified row with the given values
#     find row containing hostname in column A. if not exist, add new row
    hostname = socket.gethostname()
    try:
        row = sheet.find(hostname).row
    except Exception:
        row = len(sheet.col_values(1)) + 1
        sheet.update(f'A{row}', hostname)
    sheet.update(f'B{row}', time.ctime())
    sheet.update(f'C{row}', url)


def get_ngrok_url():
    try:
        res = requests.get("http://localhost:4040/api/tunnels")
        # Get the JSON data from the response
        res_data = res.json()
        # Get the public URL of the first tunnel
        public_url = res_data["tunnels"][0]["public_url"]
    except Exception as e:
        return str(e)
    return public_url


def write_url_to_google_sheet():
    with open('secrets/googlesheet.json') as f:
        spreadsheet_id = json.load(f)['id']
    hostname = socket.gethostname()
    edit_hostname_sheet(spreadsheet_id, hostname)
    edit_main_sheet(spreadsheet_id)


if __name__ == '__main__':
    write_url_to_google_sheet()


--- server/src/replifactory_server/create_experiment.py ---
import requests
import json
import logging

logging.basicConfig(level=logging.DEBUG)

def create_experiment():
    experiment_data = {
        "name": "Test Experiment",
        "parameters": {
            # Experiment duration settings
            "max_duration_hours": 24,
            "measurement_interval_mins": 1,
            
            # Culture configuration
            "culture_config": {
                "od_threshold": 0.3,
                "growth_rate_threshold": 0.15,
                "min_growth_rate": -0.1,
                "dilution_factor": 1.6,
                "max_drug_concentration": 100.0
            },
            
            # Device configuration
            "device_config": {
                "n_vials": 2  # Only include valid parameters
            }
        }
    }
    
    url = 'http://localhost:5000/experiments'
    print(f"Sending POST request to: {url}")
    print(f"Request data: {json.dumps(experiment_data, indent=2)}")
    
    try:
        response = requests.post(
            url,
            json=experiment_data,
            headers={'Content-Type': 'application/json'}
        )
        
        print(f"Response status code: {response.status_code}")
        print(f"Response headers: {dict(response.headers)}")
        print(f"Response text: {response.text}")
        
        if response.status_code == 201:
            print("Experiment created successfully!")
            print(json.dumps(response.json(), indent=2))
            
            # Start the experiment
            experiment_id = response.json()['id']
            start_url = f'http://localhost:5000/experiments/{experiment_id}/start'
            print(f"\nStarting experiment {experiment_id}...")
            start_response = requests.post(start_url)
            print(f"Start response: {start_response.text}")
        else:
            print(f"Error creating experiment: {response.text}")
            
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")

if __name__ == "__main__":
    create_experiment() 

--- server/src/replifactory_server/database.py ---
from flask_sqlalchemy import SQLAlchemy

# Create a single SQLAlchemy instance to be used across the application
db = SQLAlchemy() 

--- server/src/replifactory_server/database_models.py ---
from datetime import datetime
from sqlalchemy import JSON
import json
from replifactory_server.database import db

class ExperimentModel(db.Model):
    __tablename__ = 'experiments'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    status = db.Column(db.String(20), default='inactive')
    parameters = db.Column(db.Text, nullable=False)  # JSON string
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    def __init__(self, name, parameters):
        self.name = name
        self.status = 'inactive'
        self.parameters = json.dumps(parameters) if isinstance(parameters, dict) else parameters
        
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'status': self.status,
            'parameters': json.loads(self.parameters) if isinstance(self.parameters, str) else self.parameters,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

class MeasurementData(db.Model):
    __tablename__ = 'measurements'
    id = db.Column(db.Integer, primary_key=True)
    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False)
    vial = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.now)
    od = db.Column(db.Float)
    temperature = db.Column(db.Float)
    drug_concentration = db.Column(db.Float)
    growth_rate = db.Column(db.Float)

class DilutionData(db.Model):
    __tablename__ = 'dilutions'
    id = db.Column(db.Integer, primary_key=True)
    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False)
    vial = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.now)
    media_volume = db.Column(db.Float)
    drug_volume = db.Column(db.Float)
    target_concentration = db.Column(db.Float)

--- server/src/replifactory_server/init_db.py ---
from replifactory_server.server import create_app
from replifactory_server.models import db

def init_db():
    app = create_app()
    with app.app_context():
        db.create_all()
        print("Database initialized successfully")

if __name__ == '__main__':
    init_db() 

--- server/src/replifactory_server/models.py ---
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class ExperimentModel(db.Model):
    __tablename__ = 'experiments'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    status = db.Column(db.String(20), default='created')
    parameters = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.now)
    measurements = db.relationship('MeasurementData', backref='experiment', lazy=True)

class MeasurementData(db.Model):
    __tablename__ = 'measurements'
    id = db.Column(db.Integer, primary_key=True)
    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False)
    vial = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.now)
    od = db.Column(db.Float)
    temperature = db.Column(db.Float)
    drug_concentration = db.Column(db.Float)
    growth_rate = db.Column(db.Float) 

--- server/src/replifactory_server/monitor.py ---
from replifactory_server.server import create_app
from replifactory_server.database_models import db, ExperimentModel, MeasurementData
import time
from datetime import datetime, timedelta
import sys
import logging
from typing import Dict, Optional

class ExperimentMonitor:
    def __init__(self):
        self.app = create_app()
        self.socketio = self.app.config['socketio']
        self.logger = logging.getLogger(__name__)
        self.last_check = datetime.now() - timedelta(minutes=5)
        self.active_experiment: Optional[ExperimentModel] = None
        self.vial_data: Dict[int, Dict] = {}
        
    def get_active_experiment(self):
        """Get the currently running experiment."""
        with self.app.app_context():
            experiment = ExperimentModel.query.filter_by(status='running')\
                .order_by(ExperimentModel.created_at.desc())\
                .first()
            if experiment:
                self.active_experiment = experiment
                return True
            return False
            
    def print_status(self, measurements):
        """Print formatted status update and emit WebSocket events."""
        self.logger.info("="*50)
        self.logger.info(f"Status Update at {datetime.now().strftime('%H:%M:%S')}")
        self.logger.info(f"Experiment: {self.active_experiment.name}")
        self.logger.info("-"*50)
        
        # Group measurements by vial
        vial_updates = {}
        for m in measurements:
            if m.vial not in vial_updates:
                vial_updates[m.vial] = []
            vial_updates[m.vial].append(m)
        
        # Process and emit measurements for each vial
        for vial in sorted(vial_updates.keys()):
            latest = vial_updates[vial][-1]  # Get most recent measurement
            vial_data = {
                'vial': vial,
                'od': float(latest.od),  # Ensure numeric type
                'temperature': float(latest.temperature),
                'drug_concentration': float(latest.drug_concentration) if latest.drug_concentration is not None else 0.0,
                'growth_rate': float(latest.growth_rate) if latest.growth_rate is not None else 0.0,
                'timestamp': latest.timestamp.isoformat()
            }
            
            # Emit vial update via WebSocket
            with self.app.app_context():
                self.logger.debug(f"Emitting vial update: {vial_data}")
                self.socketio.emit('vial_update', vial_data)
            
            self.logger.info(f"\nVial {vial}:")
            self.logger.info(f"  OD: {latest.od:.3f}")
            self.logger.info(f"  Temperature: {latest.temperature:.1f}°C")
            if latest.drug_concentration is not None:
                self.logger.info(f"  Drug Concentration: {latest.drug_concentration:.2f}")
            if latest.growth_rate is not None:
                self.logger.info(f"  Growth Rate: {latest.growth_rate:.3f}/hr")
            
            # Calculate changes since last measurement
            if len(vial_updates[vial]) > 1:
                previous = vial_updates[vial][-2]
                od_change = latest.od - previous.od
                time_diff = (latest.timestamp - previous.timestamp).total_seconds() / 3600
                if time_diff > 0:
                    self.logger.info(f"  OD Change: {od_change:.3f} ({od_change/time_diff:.3f}/hr)")
        
        self.logger.info("="*50)
        
    def run(self):
        """Main monitoring loop."""
        self.logger.info("Starting experiment monitor...")
        self.logger.info("Waiting for active experiment...")
        
        while True:
            try:
                # Check for active experiment
                if not self.active_experiment and not self.get_active_experiment():
                    time.sleep(5)
                    continue
                
                # Get new measurements
                with self.app.app_context():
                    new_measurements = MeasurementData.query.filter(
                        MeasurementData.timestamp > self.last_check,
                        MeasurementData.experiment_id == self.active_experiment.id
                    ).order_by(MeasurementData.timestamp).all()
                    
                    if new_measurements:
                        self.print_status(new_measurements)
                        self.last_check = new_measurements[-1].timestamp
                        
                        # Check if experiment is still running
                        self.active_experiment = ExperimentModel.query.get(
                            self.active_experiment.id
                        )
                        if self.active_experiment.status != 'running':
                            self.logger.info(f"\nExperiment {self.active_experiment.name} "
                                  f"ended with status: {self.active_experiment.status}")
                            self.active_experiment = None
                            self.last_check = datetime.now() - timedelta(minutes=5)
                            self.logger.info("\nWaiting for new experiment...")
                    else:
                        self.logger.debug("No new measurements found")
                
                time.sleep(2)  # Check for updates every 2 seconds
                
            except KeyboardInterrupt:
                self.logger.info("\nStopping monitor...")
                break
            except Exception as e:
                self.logger.error(f"Error in monitor: {str(e)}")
                time.sleep(5)  # Wait before retrying

def main():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    monitor = ExperimentMonitor()
    monitor.run()

if __name__ == '__main__':
    main() 

--- server/src/replifactory_server/routes.py ---
from flask import Blueprint, request, jsonify, current_app
from datetime import datetime
import json
import logging

from replifactory_core.experiment import Experiment, ExperimentConfig
from replifactory_core.base_device import BaseDeviceConfig
from replifactory_server.database import db
from replifactory_server.database_models import ExperimentModel, MeasurementData
from replifactory_core.culture import CultureConfig

# Create blueprints
device_routes = Blueprint('device_routes', __name__)
experiment_routes = Blueprint('experiment_routes', __name__)
service_routes = Blueprint('service_routes', __name__)

logger = logging.getLogger(__name__)

# Add service routes
@service_routes.route('/service/status', methods=['GET'])
def get_service_status():
    return jsonify({
        'status': 'running',
        'timestamp': datetime.now().isoformat(),
        'mode': current_app.config.get('MODE', 'unknown')
    })


@device_routes.route('/device/status', methods=['GET'])
def get_device_status():
    if not hasattr(current_app, 'device'):
        return jsonify({'error': 'Device not initialized'}), 500
    return jsonify({'status': 'ready'})

@device_routes.route('/device/measurements', methods=['GET'])
def get_device_measurements():
    if not hasattr(current_app, 'device'):
        return jsonify({'error': 'Device not initialized'}), 500
        
    vial = request.args.get('vial', type=int)
    if not vial or not 1 <= vial <= current_app.device.config.n_vials:
        return jsonify({'error': 'Invalid vial number'}), 400
        
    try:
        measurements = current_app.device.measure_vial(vial)
        return jsonify({
            'od': measurements.od,
            'temperature': measurements.temperature,
            'rpm': measurements.rpm
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Experiment routes
experiment_routes = Blueprint('experiment_routes', __name__)

@experiment_routes.route('/experiments', methods=['GET'])
def get_experiments():
    experiments = ExperimentModel.query.all()
    return jsonify([exp.to_dict() for exp in experiments])

@experiment_routes.route('/experiments', methods=['POST'])
def create_experiment():
    try:
        data = request.get_json()
        logger.debug(f"Received experiment data: {data}")
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        # Create new experiment record
        experiment = ExperimentModel(
            name=data.get('name', f'Experiment_{datetime.now().strftime("%Y%m%d_%H%M%S")}'),
            parameters=data.get('parameters', {})
        )
        experiment.status = 'created'  # Set status after creation
        
        # Save to database
        db.session.add(experiment)
        db.session.commit()
        
        logger.info(f"Created experiment: {experiment.id}")
        
        return jsonify({
            'message': 'Experiment created successfully',
            'id': experiment.id,
            'name': experiment.name,
            'status': experiment.status
        }), 201
        
    except Exception as e:
        logger.error(f"Error creating experiment: {str(e)}")
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@experiment_routes.route('/experiments/<int:id>', methods=['GET'])
def get_experiment(id):
    experiment = ExperimentModel.query.get_or_404(id)
    return jsonify(experiment.to_dict())

@experiment_routes.route('/experiments/current/status', methods=['PUT'])
def update_experiment_status():
    status = request.json['status']
    
    if not hasattr(current_app, 'experiment'):
        return jsonify({'error': 'No experiment selected'}), 404
        
    if status == 'running':
        current_app.experiment.start()
    elif status == 'stopped':
        current_app.experiment.stop()
    elif status == 'paused':
        current_app.experiment.pause()
        
    return jsonify({'message': f'Experiment {status}'})

@experiment_routes.route('/plot/<int:vial>', methods=['GET'])
def get_culture_plot(vial):
    if not hasattr(current_app, 'experiment'):
        return jsonify({'error': 'No experiment selected'}), 404
        
    measurements = MeasurementData.query.filter_by(
        experiment_id=current_app.experiment.model.id,
        vial=vial
    ).order_by(MeasurementData.timestamp).all()
    
    # Create plot data
    data = {
        'times': [m.timestamp.isoformat() for m in measurements],
        'ods': [m.od for m in measurements],
        'drug_concentrations': [m.drug_concentration for m in measurements],
        'growth_rates': [m.growth_rate for m in measurements]
    }
    
    return jsonify(data)

@experiment_routes.route('/experiments/<int:id>/start', methods=['POST'])
def start_experiment(id):
    try:
        exp_model = ExperimentModel.query.get_or_404(id)
        
        # Get parameters from database
        parameters = json.loads(exp_model.parameters) if isinstance(exp_model.parameters, str) else exp_model.parameters
        
        # Create culture config from parameters
        culture_config = CultureConfig(
            od_threshold=parameters['culture_config'].get('od_threshold', 0.3),
            growth_rate_threshold=parameters['culture_config'].get('growth_rate_threshold', 0.15),
            min_growth_rate=parameters['culture_config'].get('min_growth_rate', -0.1),
            dilution_factor=parameters['culture_config'].get('dilution_factor', 1.6),
            max_drug_concentration=parameters['culture_config'].get('max_drug_concentration', 100.0)
        )
        
        # Create experiment config
        config = ExperimentConfig(
            max_duration_hours=parameters.get('max_duration_hours', 24),
            measurement_interval_mins=parameters.get('measurement_interval_mins', 1),
            culture_config=culture_config,
            device_config=BaseDeviceConfig(**parameters.get('device_config', {}))
        )
        
        # Initialize experiment
        if not hasattr(current_app, 'device'):
            current_app.logger.error("Device not initialized")
            return jsonify({'error': 'Device not initialized'}), 500
            
        # Create experiment
        current_app.experiment = Experiment(
            device=current_app.device,
            config=config,
            protocol=current_app.simulation_runner.protocol if hasattr(current_app, 'simulation_runner') else None
        )
        current_app.experiment.model = exp_model  # Set the experiment model
        
        # Start the experiment
        if hasattr(current_app, 'simulation_runner'):
            current_app.logger.info("Starting experiment in simulation mode")
            current_app.simulation_runner.experiment = current_app.experiment
            current_app.simulation_runner.experiment.model = exp_model  # Set the model on the simulation runner's experiment
            current_app.simulation_runner.start()
        else:
            current_app.logger.info("Starting experiment in hardware mode")
            current_app.experiment.start()
        
        # Update experiment status in database
        exp_model.status = 'running'
        db.session.commit()
        
        return jsonify({
            'message': 'Experiment started successfully',
            'experiment': {
                'id': exp_model.id,
                'name': exp_model.name,
                'status': exp_model.status
            }
        })
        
    except Exception as e:
        current_app.logger.error(f"Error starting experiment: {str(e)}")
        return jsonify({'error': str(e)}), 500

@experiment_routes.route('/experiments/active', methods=['GET'])
def get_active_experiment():
    """Get currently running experiment."""
    try:
        current_app.logger.info("Fetching active experiment...")
        
        # Get the most recent running experiment
        experiment = ExperimentModel.query\
            .filter_by(status='running')\
            .order_by(ExperimentModel.created_at.desc())\
            .first()
            
        response_data = {'experiment': experiment.to_dict() if experiment else None}
        response = current_app.make_response(response_data)
        response.headers.add('Access-Control-Allow-Origin', '*')
        
        if experiment:
            current_app.logger.info(f"Found active experiment: ID={experiment.id}, Name={experiment.name}")
        else:
            current_app.logger.info("No active experiments found")
            
        return response
            
    except Exception as e:
        current_app.logger.error(f"Error getting active experiment: {str(e)}", exc_info=True)
        return jsonify({'error': str(e)}), 500

# Add to_dict method to ExperimentModel
def to_dict(self):
    return {
        'id': self.id,
        'name': self.name,
        'status': self.status,
        'parameters': json.loads(self.parameters) if isinstance(self.parameters, str) else self.parameters,
        'created_at': self.created_at.isoformat() if self.created_at else None
    }

ExperimentModel.to_dict = to_dict

--- server/src/replifactory_server/server.py ---
from flask import Flask
from flask_cors import CORS
from flask_migrate import Migrate
import logging
import os
from pathlib import Path
from waitress import serve
from flask_socketio import SocketIO

from replifactory_server.routes import device_routes, experiment_routes, service_routes
from replifactory_server.database import db
from replifactory_server.database_models import MeasurementData
from replifactory_simulation.factory import SimulationFactory
from replifactory_simulation.growth_model import GrowthModelParameters
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.base_device import BaseDeviceConfig
from replifactory_core.experiment import ExperimentConfig
import sys

logger = logging.getLogger(__name__)


def create_app(config=None):
    # Set up logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    # Create Flask app
    app = Flask(__name__)
    
    # Initialize SocketIO
    socketio = SocketIO(app, 
        cors_allowed_origins="*",
        logger=True,
        engineio_logger=True,
        async_mode='threading'
    )
    app.config['socketio'] = socketio
    
    # Ensure instance folder exists
    instance_path = Path(app.instance_path)
    instance_path.mkdir(parents=True, exist_ok=True)
    
    # Set database path
    db_path = instance_path / 'replifactory.db'
    
    # Load default configuration
    default_config = {
        'SQLALCHEMY_DATABASE_URI': f'sqlite:///{db_path}',
        'SQLALCHEMY_TRACK_MODIFICATIONS': False,
        'MODE': 'simulation',  # Default to simulation mode
        'DATABASE_PATH': db_path,
        'TIME_ACCELERATION': 100.0
    }
    
    # Apply default config
    app.config.from_mapping(default_config)
    
    # Override with provided config if any
    if config:
        app.config.update(config)
    
    logger.info(f"Database path: {db_path}")
    logger.info(f"Running in {app.config['MODE']} mode")
    
    # Initialize extensions
    CORS(app)
    db.init_app(app)
    Migrate(app, db)
    
    # Register blueprints
    app.register_blueprint(device_routes)
    app.register_blueprint(experiment_routes)
    app.register_blueprint(service_routes)
    
    # Initialize device and simulation
    with app.app_context():
        try:
            # Create database tables
            db.create_all()
            logger.info("Database tables created successfully")
            
            # Initialize device based on mode
            logger.info(f"Current mode: {app.config['MODE']}")
            if app.config['MODE'] == 'simulation':
                logger.info("Initializing simulation mode")
                factory = SimulationFactory()
                device_config = BaseDeviceConfig()
                model_params = GrowthModelParameters()
                
                # Create device
                app.device = factory.create_device(device_config, model_params)
                logger.info("Device created successfully")
                
                # Create simulation runner
                app.simulation_runner = SimulationRunner(
                    device=app.device,
                    config=ExperimentConfig(),
                    model_params=model_params,
                    time_acceleration=app.config.get('TIME_ACCELERATION', 100.0),
                    app=app,
                    db=db,
                    measurement_model=MeasurementData
                )
                logger.info(f"Simulation initialized with {app.config.get('TIME_ACCELERATION', 100.0)}x time acceleration")
                logger.info(f"Device initialized: {hasattr(app, 'device')}")
                logger.info(f"Simulation runner initialized: {hasattr(app, 'simulation_runner')}")
            else:
                logger.info("Initializing hardware mode")
                # Initialize hardware device here
                pass
                
        except Exception as e:
            logger.error(f"Error during initialization: {str(e)}")
            logger.error(f"Current app config: {app.config}")
            raise
    
    return app

def run_server(host='0.0.0.0', port=5000, mode='simulation', config=None):
    if config is None:
        config = {}
    config['MODE'] = mode
    
    app = create_app(config)
    logger.info(f"Starting server in {mode} mode on {host}:{port}")
    logger.info(f"Time acceleration factor: {app.config.get('TIME_ACCELERATION', 100.0)}x")
    
    socketio = app.config['socketio']
    socketio.run(app, host=host, port=port, debug=True, allow_unsafe_werkzeug=True)

def main():
    development = len(sys.argv) > 1 and sys.argv[1] == 'develop'
    
    config = {
        'MODE': 'simulation',  # Always use simulation mode
        'TIME_ACCELERATION': 100.0
    }
    
    if development:
        print("Running in development mode")
        app = create_app(config)
        app.run(debug=True, host="0.0.0.0", port=5000)
    else:
        print("Running in production mode")
        run_server(host="0.0.0.0", port=5000, mode='simulation', config=config)

if __name__ == '__main__':
    main()

--- server/src/replifactory_server/start_experiment.py ---
import requests
import json
import logging

logging.basicConfig(level=logging.DEBUG)

def start_experiment(experiment_id):
    url = f'http://localhost:5000/experiments/{experiment_id}/start'
    print(f"Starting experiment {experiment_id}")
    
    try:
        response = requests.post(url)
        print(f"Response status code: {response.status_code}")
        print(f"Response: {response.text}")
        
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")

if __name__ == "__main__":
    # Get the most recent experiment
    response = requests.get('http://localhost:5000/experiments')
    if response.status_code == 200:
        experiments = response.json()
        if experiments:
            latest_experiment = experiments[-1]
            start_experiment(latest_experiment['id'])
        else:
            print("No experiments found")
    else:
        print(f"Failed to get experiments: {response.text}") 

--- server/src/replifactory_server/start_server.py ---
import argparse
import logging
from replifactory_server.server import run_server

def main():
    parser = argparse.ArgumentParser(description='Start the Replifactory server')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5000, help='Port to listen on')
    parser.add_argument('--mode', default='simulation', choices=['simulation', 'hardware'], 
                       help='Server mode (simulation or hardware)')
    parser.add_argument('--debug', action='store_true', help='Enable debug logging')
    parser.add_argument('--time-acceleration', type=float, default=100.0,
                       help='Time acceleration factor for simulation mode (default: 100.0)')
    
    args = parser.parse_args()
    
    # Set up logging
    logging.basicConfig(
        level=logging.DEBUG if args.debug else logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Run server
    config = {
        'MODE': args.mode,
        'TIME_ACCELERATION': args.time_acceleration
    }
    run_server(host=args.host, port=args.port, mode=args.mode, config=config)

if __name__ == '__main__':
    main() 

--- simulation/examples/quick_start.py ---
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.experiment import ExperimentConfig
from replifactory_simulation.growth_model import GrowthModelParameters
import time
import logging
from datetime import datetime

def main():
    # Set up logging
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)
    
    # Create configuration
    exp_config = ExperimentConfig(
        measurement_interval_mins=10,
        max_duration_hours=24,
        max_generations=None  # Allow experiment to run full duration
    )
    
    # Configure realistic growth parameters
    model_params = GrowthModelParameters(
        doubling_time_mins=30,        # Fast growing bacteria
        initial_od=0.1,               # Starting OD
        carrying_capacity=1.0,        # Maximum OD
        ic50_initial=10.0,            # Initial drug resistance
        adaptation_rate_max=0.1       # Allow for evolution
    )
    
    print(f"Starting simulation at {datetime.now().strftime('%H:%M:%S')}")
    print(f"Running {exp_config.max_duration_hours}-hour experiment at 10000x speed")
    print("Press Ctrl+C to stop early\n")
    
    # Create simulation
    runner = SimulationRunner(
        config=exp_config,
        model_params=model_params,
        time_acceleration=10000.0
    )
    
    try:
        # Start simulation
        runner.start()
        
        # Monitor progress
        start_time = time.time()
        last_print = start_time
        
        while runner.experiment._status == "running":
            current_time = time.time()
            
            # Print status update every 5 seconds
            if current_time - last_print >= 5.0:
                status = runner.experiment.status
                sim_hours = status['duration_hours']
                
                print(f"\nSimulation Time: {sim_hours:.1f}h / {exp_config.max_duration_hours}h")
                print("Culture Status:")
                
                for vial, data in status['cultures'].items():
                    print(f"  Vial {vial}:")
                    print(f"    OD: {data['od']:.3f}")
                    if 'drug_concentration' in data:
                        print(f"    Drug: {data['drug_concentration']:.1f}")
                    if 'growth_rate' in data:
                        print(f"    Growth Rate: {data['growth_rate']:.3f}/hr")
                        
                last_print = current_time
            
            # Don't burn CPU
            time.sleep(0.1)
            
    except KeyboardInterrupt:
        print("\nStopping simulation early...")
    finally:
        runner.stop()
        
        # Show results
        print("\nGenerating plots...")
        runner.data_logger.plot_growth_curves()
        
        # Load and show final statistics
        df = runner.data_logger.load_measurements()
        if not df.empty:
            print("\nExperiment Summary:")
            print(f"Duration: {df['timestamp'].max() - df['timestamp'].min()}")
            print(f"Total measurements: {len(df)}")
            print("\nFinal ODs:")
            final_ods = df.groupby('vial').last()['od']
            print(final_ods)
        else:
            logger.warning("No measurements recorded!")

if __name__ == "__main__":
    main()

--- simulation/examples/run_simulation.py ---
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.experiment import ExperimentConfig
from replifactory_simulation.growth_model import GrowthModelParameters
import time
import logging

def main():
    # Set up logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Create configuration
    exp_config = ExperimentConfig(
        measurement_interval_mins=10,
        max_duration_hours=24
    )
    
    model_params = GrowthModelParameters(
        doubling_time_mins=30,
        initial_od=0.1,
        carrying_capacity=1.0,
        ic50_initial=10.0
    )
    
    # Create and start simulation
    runner = SimulationRunner(
        config=exp_config,
        model_params=model_params,
        time_acceleration=100.0  # 100x speed
    )
    
    try:
        runner.start()
        
        # Monitor simulation
        while runner.experiment._status == "running":
            status = runner.experiment.status
            logging.info(f"Time: {status['duration_hours']:.1f}h")
            
            # Print culture status every minute
            for vial, data in status['cultures'].items():
                logging.info(
                    f"Vial {vial}: OD={data['od']:.3f}, "
                    f"Drug={data.get('drug_concentration', 0.0):.1f}"
                )
            
            time.sleep(60)  # Update display every minute
            
    except KeyboardInterrupt:
        logging.info("Stopping simulation...")
    finally:
        runner.stop()
        
        # Generate final plots and summary
        runner.data_logger.plot_growth_curves()
        
        df = runner.data_logger.load_measurements()
        if not df.empty:
            logging.info("\nExperiment Summary:")
            duration = df['timestamp'].max() - df['timestamp'].min()
            logging.info(f"Duration: {duration}")
            logging.info(f"Total measurements: {len(df)}")
            logging.info("\nFinal ODs:")
            final_ods = df.groupby('vial').last()['od']
            logging.info(final_ods)
        else:
            logging.warning("No measurements recorded!")

if __name__ == "__main__":
    main()

--- simulation/src/replifactory_simulation/__init__.py ---


--- simulation/src/replifactory_simulation/devices.py ---
from dataclasses import dataclass
import time
from typing import Dict, Optional, Tuple
import threading
import numpy as np
import logging

from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface, StirrerSpeed,
    DeviceError
)
from replifactory_core.parameters import ODParameters

from .growth_model import GrowthModel, GrowthModelParameters

logger = logging.getLogger(__name__)

@dataclass
class SimulatedPump(PumpInterface):    
    pump_number: int
    flow_rate_mlps: float = 1.0
    
    def __post_init__(self):
        self._is_pumping = False
        self._volume_pumped = 0.0
        self._lock = threading.Lock()  # Lock for thread safety
    
    def pump(self, volume_ml: float) -> None:
        logger.debug(f"Pump {self.pump_number} attempting to pump {volume_ml}ml")
        if not self._lock.acquire(blocking=False):  # Try to acquire lock
            raise DeviceError("Pump already in use")
        
        try:
            self._is_pumping = True
            duration = abs(volume_ml) / self.flow_rate_mlps
            logger.debug(f"Pump {self.pump_number} pumping for {duration:.2f}s")
            time.sleep(duration)  # Simulate pumping time
            self._volume_pumped += volume_ml
            logger.debug(f"Pump {self.pump_number} finished pumping")
        finally:
            self._is_pumping = False
            self._lock.release()
    
    def stop(self) -> None:
        logger.debug(f"Stopping pump {self.pump_number}")
        self._is_pumping = False
    
    @property
    def is_pumping(self) -> bool:
        return self._is_pumping
    
    @property
    def pumped_volume(self) -> float:
        return self._volume_pumped


class SimulatedValves(ValveInterface):
    def __init__(self):
        self._states = {i: False for i in range(1, 8)}  # False = closed
        logger.debug("Initialized valve states")
    
    def open(self, valve_number: int) -> None:
        logger.debug(f"Opening valve {valve_number}")
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        self._states[valve_number] = True
        time.sleep(0.1)  # Simulate valve movement
    
    def close(self, valve_number: int) -> None:
        logger.debug(f"Closing valve {valve_number}")
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        self._states[valve_number] = False
        time.sleep(0.1)  # Simulate valve movement
    
    def is_open(self, valve_number: int) -> bool:
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        return self._states[valve_number]
    
    def close_all(self) -> None:
        logger.debug("Closing all valves")
        for v in range(1, 8):
            self._states[v] = False


class SimulatedStirrer(StirrerInterface):
    def __init__(self):
        self._speeds = {i: StirrerSpeed.STOPPED for i in range(1, 8)}
        self._rpm_map = {
            StirrerSpeed.STOPPED: 0.0,
            StirrerSpeed.LOW: 400.0,
            StirrerSpeed.HIGH: 1200.0
        }
        logger.debug("Initialized stirrer speeds")
    
    def set_speed(self, vial: int, speed: StirrerSpeed) -> None:
        logger.debug(f"Setting vial {vial} stirrer to {speed}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
        self._speeds[vial] = speed
        time.sleep(0.2)  # Simulate speed change
    
    def measure_rpm(self, vial: int) -> float:
        logger.debug(f"Measuring RPM for vial {vial}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
        base_rpm = self._rpm_map[self._speeds[vial]]
        # Add some noise
        rpm = base_rpm * (1 + 0.05 * (2 * np.random.random() - 1))
        logger.debug(f"Vial {vial} RPM: {rpm:.1f}")
        return rpm
    
    def stop_all(self) -> None:
        logger.debug("Stopping all stirrers")
        for v in range(1, 8):
            self._speeds[v] = StirrerSpeed.STOPPED


class SimulatedODSensor(ODSensorInterface):
    """Simulates bacterial growth and OD measurements."""
    
    def __init__(self, model_params: Optional[GrowthModelParameters] = None):
        # Initialize growth models for each vial
        self._growth_models = {
            i: GrowthModel(parameters=model_params)
            for i in range(1, 8)
        }
        
        # Blank values for each vial
        self.blank_values = {i: 1000.0 for i in range(1, 8)}  # mV
        logger.debug("Initialized OD sensor with growth models")
        
    def measure_blank(self, vial: int) -> float:
        """Measure blank (empty vial) signal."""
        logger.debug(f"Measuring blank for vial {vial}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Add some noise to the blank measurement
        blank = self.blank_values[vial] * (1 + 0.005 * np.random.randn())
        time.sleep(0.1)  # Simulate measurement time
        logger.debug(f"Vial {vial} blank: {blank:.1f}mV")
        return blank
        
    def measure_od(self, vial: int, parameters: Optional[ODParameters] = None) -> Tuple[float, float]:
        logger.debug(f"Measuring OD for vial {vial}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Get current OD from growth model
        model = self._growth_models[vial]
        
        # Add measurement noise
        measured_od = model.od * (1 + 0.02 * np.random.randn())
        signal = 1000 * np.exp(-measured_od) * (1 + 0.01 * np.random.randn())
        
        time.sleep(0.1)  # Simulate measurement time
        logger.debug(f"Vial {vial} OD: {measured_od:.3f}, Signal: {signal:.1f}mV")
        return measured_od, signal
        
    def update_drug_concentration(self, vial: int, concentration: float):
        """Update drug concentration after dilution."""
        logger.debug(f"Updating vial {vial} drug concentration to {concentration}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        model = self._growth_models[vial]
        model.drug_concentration = concentration


class SimulatedThermometer(ThermometerInterface):
    def __init__(self):
        self._temp_setpoint = 37.0
        logger.debug("Initialized thermometer")
        
    def measure_temperature(self) -> Dict[str, float]:
        logger.debug("Measuring temperatures")
        # Add noise to temperature
        vial_temp = self._temp_setpoint + 0.5 * (2 * np.random.random() - 1)
        board_temp = 35.0 + 0.2 * (2 * np.random.random() - 1)
        
        time.sleep(0.1)  # Simulate measurement
        logger.debug(f"Temperatures - Vials: {vial_temp:.1f}°C, Board: {board_temp:.1f}°C")
        return {
            'vials': vial_temp,
            'board': board_temp
        }



--- simulation/src/replifactory_simulation/factory.py ---
from typing import Dict, Optional

from replifactory_core.factory import DeviceComponentFactory
from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface
)
from replifactory_core.base_device import BaseDevice, BaseDeviceConfig

from .devices import (
    SimulatedPump, SimulatedValves, SimulatedStirrer,
    SimulatedODSensor, SimulatedThermometer
)
from .growth_model import GrowthModelParameters

class SimulationFactory(DeviceComponentFactory):
    """Factory for creating simulated device components."""
    
    def create_device(
        self, 
        config: BaseDeviceConfig,
        model_params: Optional[GrowthModelParameters] = None
    ) -> BaseDevice:
        """Create complete simulated device."""
        pumps = {
            1: self.create_pump(1),  # Media
            2: self.create_pump(2),  # Drug
            4: self.create_pump(4)   # Waste
        }
        
        return BaseDevice(
            config=config,
            pumps=pumps,
            valves=self.create_valves(),
            stirrer=self.create_stirrer(),
            od_sensor=self.create_od_sensor(model_params),
            thermometer=self.create_thermometer()
        )
    
    def create_pump(self, pump_number: int) -> PumpInterface:
        """Create simulated pump."""
        return SimulatedPump(pump_number=pump_number)
    
    def create_valves(self) -> ValveInterface:
        """Create simulated valve control."""
        return SimulatedValves()
    
    def create_stirrer(self) -> StirrerInterface:
        """Create simulated stirrer control."""
        return SimulatedStirrer()
    
    def create_od_sensor(self, model_params: Optional[GrowthModelParameters] = None) -> ODSensorInterface:
        """Create simulated OD sensor."""
        return SimulatedODSensor(model_params)
    
    def create_thermometer(self) -> ThermometerInterface:
        """Create simulated thermometer."""
        return SimulatedThermometer() 

--- simulation/src/replifactory_simulation/growth_model.py ---
from dataclasses import dataclass
import numpy as np
from typing import Optional


@dataclass
class GrowthModelParameters:
    """Parameters controlling bacterial growth simulation.
    
    Attributes:
        initial_od: Starting optical density
        doubling_time_mins: Time for population to double without drug
        carrying_capacity: Maximum OD the culture can reach
        mu_min: Minimum growth rate (can be negative for death)
        ic50_initial: Initial drug concentration causing 50% growth inhibition
        ic10_ic50_ratio: Ratio of IC10 to IC50 (controls dose response curve)
        adaptation_rate_max: Maximum rate of drug adaptation
        adaptation_rate_ic10_ic50_ratio: Controls adaptation vs. drug concentration
    """
    initial_od: float = 0.05
    doubling_time_mins: float = 20.0
    carrying_capacity: float = 0.9
    mu_min: float = -0.1
    ic50_initial: float = 5.0
    ic10_ic50_ratio: float = 0.5
    adaptation_rate_max: float = 0.08
    adaptation_rate_ic10_ic50_ratio: float = 0.8


class GrowthModel:
    """Simulates bacterial growth with drug adaptation.
    
    Implements core growth model including:
    - Basic bacterial growth
    - Drug response
    - Evolution of drug resistance
    - Population carrying capacity
    
    The model tracks:
    - Current population (OD)
    - Drug concentration
    - Drug resistance (IC50)
    - Growth rate
    """
    
    def __init__(self, parameters: Optional[GrowthModelParameters] = None):
        """Initialize growth model.
        
        Args:
            parameters: Growth model parameters. Uses defaults if None.
        """
        self.params = parameters or GrowthModelParameters()
        
        # Calculate base growth rate from doubling time
        self.mu_max = np.log(2) / (self.params.doubling_time_mins / 60)
        
        # Initialize state
        self.od = self.params.initial_od
        self.drug_concentration = 0.0
        self.ic50 = self.params.ic50_initial
        self._growth_rate = None
        
    def growth_rate(self, drug_conc: float, od: float) -> float:
        """Calculate growth rate under given conditions.
        
        Combines effects of:
        - Base growth rate
        - Drug inhibition
        - Carrying capacity
        
        Args:
            drug_conc: Current drug concentration
            od: Current optical density
            
        Returns:
            Growth rate in 1/hour
        """
        # Calculate drug effect using 4-parameter logistic
        ic10 = self.ic50 * self.params.ic10_ic50_ratio
        k = np.log(9) / (self.ic50 - ic10)
        drug_effect = self.params.mu_min + (
            self.mu_max / (1 + np.exp(-k * (self.ic50 - drug_conc)))
        )
        
        # Apply carrying capacity limitation
        capacity_effect = (1 - od / self.params.carrying_capacity)
        
        return drug_effect * capacity_effect
    
    def adaptation_rate(self, drug_conc: float) -> float:
        """Calculate rate of drug resistance adaptation.
        
        Models evolution of drug resistance using modified Gaussian curve.
        
        Args:
            drug_conc: Current drug concentration
            
        Returns:
            Adaptation rate in 1/hour
        """
        ic10 = self.ic50 * self.params.ic10_ic50_ratio
        k_adapt = -np.log(self.params.adaptation_rate_ic10_ic50_ratio) / ((ic10 - self.ic50) ** 2)
        return self.params.adaptation_rate_max * np.exp(-k_adapt * ((drug_conc - self.ic50) ** 2))
    
    def update(self, timestep_mins: float, new_drug_conc: Optional[float] = None):
        """Update model state for one timestep.
        
        Args:
            timestep_mins: Time step in minutes
            new_drug_conc: New drug concentration if changed, else uses current
            
        Updates internal state:
        - OD based on growth
        - IC50 based on adaptation
        - Stores current growth rate
        """
        if new_drug_conc is not None:
            self.drug_concentration = new_drug_conc
            
        # Calculate current growth rate
        self._growth_rate = self.growth_rate(self.drug_concentration, self.od)
        
        # Update population
        hours = timestep_mins / 60
        self.od *= np.exp(self._growth_rate * hours)
        
        # Update drug resistance
        adapt_rate = self.adaptation_rate(self.drug_concentration)
        self.ic50 *= np.exp(adapt_rate * hours)
    
    def dilute(self, dilution_factor: float, new_drug_conc: Optional[float] = None):
        """Perform dilution operation.
        
        Args:
            dilution_factor: Factor by which culture is diluted
            new_drug_conc: New drug concentration after dilution
        """
        self.od /= dilution_factor
        if new_drug_conc is not None:
            self.drug_concentration = new_drug_conc
            
    @property
    def growth_rate_current(self) -> float:
        """Get most recently calculated growth rate."""
        return self._growth_rate if self._growth_rate is not None else 0.0

--- simulation/src/replifactory_simulation/logging.py ---
from dataclasses import dataclass, asdict
from datetime import datetime
import json
import os
from pathlib import Path
from typing import Dict, List, Optional, Union
import pandas as pd
import numpy as np

@dataclass
class MeasurementLog:
    """Single measurement data point.
    
    Attributes:
        timestamp: Time of measurement
        vial: Vial number
        od: Optical density
        temperature: Temperature in Celsius
        drug_concentration: Current drug concentration
        growth_rate: Calculated growth rate if available
        action: Control action taken if any
    """
    timestamp: datetime
    vial: int
    od: float
    temperature: float
    drug_concentration: float
    growth_rate: Optional[float] = None
    action: Optional[str] = None

@dataclass
class ExperimentLog:
    """Complete experiment log.
    
    Attributes:
        experiment_id: Unique experiment identifier
        start_time: Experiment start time
        config: Experiment configuration
        measurements: List of all measurements
        events: List of significant events
    """
    experiment_id: str
    start_time: datetime
    config: Dict
    measurements: List[MeasurementLog] = None
    events: List[Dict] = None
    
    def __post_init__(self):
        self.measurements = self.measurements or []
        self.events = self.events or []


class SimulationLogger:
    """Handles data logging for simulated experiments.
    
    Logs measurements, events, and configuration to both:
    - CSV files for easy analysis
    - JSON for complete state preservation
    
    Args:
        output_dir: Directory for log files
        experiment_id: Unique experiment identifier
    """
    
    def __init__(self, output_dir: Union[str, Path], experiment_id: Optional[str] = None):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        self.experiment_id = experiment_id or datetime.now().strftime("%Y%m%d_%H%M%S")
        self.experiment_dir = self.output_dir / self.experiment_id
        self.experiment_dir.mkdir(exist_ok=True)
        
        self.log = ExperimentLog(
            experiment_id=self.experiment_id,
            start_time=datetime.now(),
            config={}
        )
        
    def log_config(self, config: Dict):
        """Log experiment configuration."""
        self.log.config = config
        self._save_json()
        
    def log_measurement(
        self,
        vial: int,
        od: float,
        temperature: float,
        drug_concentration: float,
        growth_rate: Optional[float] = None,
        action: Optional[str] = None
    ):
        """Log single measurement."""
        measurement = MeasurementLog(
            timestamp=datetime.now(),
            vial=vial,
            od=od,
            temperature=temperature,
            drug_concentration=drug_concentration,
            growth_rate=growth_rate,
            action=action
        )
        self.log.measurements.append(measurement)
        self._append_csv(measurement)
        
    def log_event(self, event_type: str, details: Dict):
        """Log significant event."""
        event = {
            'timestamp': datetime.now().isoformat(),
            'type': event_type,
            **details
        }
        self.log.events.append(event)
        self._save_json()
        
    def _append_csv(self, measurement: MeasurementLog):
        """Append measurement to CSV file."""
        csv_path = self.experiment_dir / 'measurements.csv'
        
        # Convert to dict for pandas
        data = asdict(measurement)
        data['timestamp'] = data['timestamp'].isoformat()
        
        # Create or append to CSV
        df = pd.DataFrame([data])
        if not csv_path.exists():
            df.to_csv(csv_path, index=False)
        else:
            df.to_csv(csv_path, mode='a', header=False, index=False)
            
    def _save_json(self):
        """Save complete log to JSON."""
        json_path = self.experiment_dir / 'experiment.json'
        
        # Convert to serializable format
        data = asdict(self.log)
        data['start_time'] = data['start_time'].isoformat()
        
        for m in data['measurements']:
            m['timestamp'] = m['timestamp'].isoformat()
            
        with open(json_path, 'w') as f:
            json.dump(data, f, indent=2)
            
    def load_measurements(self) -> pd.DataFrame:
        """Load measurements as pandas DataFrame."""
        csv_path = self.experiment_dir / 'measurements.csv'
        if not csv_path.exists():
            return pd.DataFrame()
            
        df = pd.read_csv(csv_path)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        return df
    
    def plot_growth_curves(self):
        """Plot OD and drug concentration over time."""
        import matplotlib.pyplot as plt
        
        df = self.load_measurements()
        if df.empty:
            return
            
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)
        
        # Plot OD
        for vial in df['vial'].unique():
            vial_data = df[df['vial'] == vial]
            ax1.plot(vial_data['timestamp'], vial_data['od'], 
                    label=f'Vial {vial}')
        ax1.set_ylabel('OD')
        ax1.set_yscale('log')
        ax1.legend()
        ax1.grid(True)
        
        # Plot drug concentration
        for vial in df['vial'].unique():
            vial_data = df[df['vial'] == vial]
            ax2.plot(vial_data['timestamp'], vial_data['drug_concentration'],
                    label=f'Vial {vial}')
        ax2.set_ylabel('Drug Concentration')
        ax2.set_xlabel('Time')
        ax2.grid(True)
        
        plt.tight_layout()
        plt.savefig(self.experiment_dir / 'growth_curves.png')
        plt.close() 

--- simulation/src/replifactory_simulation/runner.py ---
from datetime import datetime
from replifactory_core.protocols import MorbidostatProtocol, MorbidostatConfig
from dataclasses import asdict
import logging
from threading import Thread
from typing import Optional
import time
from replifactory_core.base_device import BaseDevice
from replifactory_core.experiment import ExperimentConfig, Experiment
from replifactory_simulation.factory import SimulationFactory
from replifactory_simulation.growth_model import GrowthModelParameters
from replifactory_simulation.logging import SimulationLogger, MeasurementLog


from .factory import SimulationFactory
from .growth_model import GrowthModelParameters
from .logging import SimulationLogger
import time
from threading import Thread, Event
from typing import Optional
import logging
from flask_sqlalchemy import SQLAlchemy
from replifactory_server.database_models import db, MeasurementData
from dataclasses import asdict

db = SQLAlchemy()
logger = logging.getLogger(__name__)

class SimulationRunner:
    """Runs simulated evolution experiments."""
    
    def __init__(
        self,
        config: ExperimentConfig = ExperimentConfig(),
        model_params: Optional[GrowthModelParameters] = None,
        time_acceleration: float = 100.0,
        device: Optional[BaseDevice] = None,
        app=None,
        db=None,  # Add database parameter
        measurement_model=None  # Add measurement model parameter
    ):
        self._log = logging.getLogger("SimulationRunner")
        self.time_acceleration = time_acceleration
        self.config = config
        self.model_params = model_params or GrowthModelParameters()  # Store model_params
        self._running = False
        self._thread: Optional[Thread] = None
        self.app = app
        self.db = db  # Store database reference
        self.measurement_model = measurement_model  # Store measurement model reference
        
        # Create device if not provided
        if device is None:
            factory = SimulationFactory()
            device = factory.create_device(config.device_config, self.model_params)
        self.device = device
        
        # Initialize protocol
        self.protocol = MorbidostatProtocol(MorbidostatConfig())
        
        # Initialize experiment
        self.experiment = Experiment(
            device=self.device,
            config=self.config,
            protocol=self.protocol
        )
        
        # Initialize data logging
        self.data_logger = SimulationLogger(
            output_dir="data/experiments",
            experiment_id=self.experiment.name
        )
        self.data_logger.log_config(asdict(config))
        
    def start(self):
        if self._thread is not None and self._thread.is_alive():
            self._log.warning("Simulation already running")
            return
            
        self._running = True
        
        # Log initial state
        self.data_logger.log_config({
            'experiment': self.config.__dict__,
            'growth_model': self.model_params.__dict__,
            'time_acceleration': self.time_acceleration
        })
        
        # Start experiment
        self._log.info("Starting experiment...")
        self.experiment.start()
        
        # Take initial measurements
        self._log.info("Taking initial measurements...")
        try:
            self._update_simulation()
        except Exception as e:
            self._log.error(f"Error taking initial measurements: {str(e)}")
            self.experiment.stop()
            return
            
        # Start simulation thread
        self._thread = Thread(
            target=self._run_simulation,
            name="SimulationThread",
            daemon=True
        )
        self._thread.start()
        self._log.info("Simulation started")
        
    def stop(self):
        self._log.info("Stopping simulation...")
        self._running = False
        
        if self._thread and self._thread.is_alive():
            # Wait with timeout
            self._thread.join(timeout=5.0)
            if self._thread.is_alive():
                self._log.warning("Simulation thread did not stop cleanly")
        
        self._thread = None
        self.experiment.stop()
        self._log.info("Simulation stopped")
        
    def _run_simulation(self):
        try:
            update_interval = self.config.measurement_interval_mins * 60  # seconds
            update_interval /= self.time_acceleration
            
            self._last_update = time.time()
            self._log.info(f"Update interval: {update_interval:.2f} seconds")
            
            while self._running and self.experiment._status == "running":
                current_time = time.time()
                elapsed = current_time - self._last_update
                
                if elapsed >= update_interval:
                    self._log.debug(f"Running update at {current_time}")
                    try:
                        self._update_simulation()
                        self._last_update = current_time
                    except Exception as e:
                        self._log.error(f"Update error: {e}")
                        if not isinstance(e, (ValueError, RuntimeError)):
                            raise
                
                # Prevent CPU spinning while checking more frequently
                time.sleep(min(0.1, update_interval / 10))
                
        except Exception as e:
            self._log.error(f"Simulation error: {e}")
            self.data_logger.log_event('error', {'message': str(e)})
        finally:
            if self.experiment._status != "stopped":
                self.experiment.stop()
                
    def _update_simulation(self):
        """Update simulation state and record measurements."""
        # Update growth models
        od_sensor = self.device._od_sensor
        for vial in range(1, self.config.device_config.n_vials + 1):
            model = od_sensor._growth_models[vial]
            timestep = self.config.measurement_interval_mins / self.time_acceleration
            model.update(timestep_mins=timestep)
        
        # Update experiment
        self.experiment.update()
        
        # Log status
        status = self.experiment.status
        for vial, data in status['cultures'].items():
            if data is None:
                self._log.warning(f"No data for vial {vial}")
                continue
                
            # Extract values with safe defaults
            od = data.get('od', 0.0)
            drug_conc = data.get('drug_concentration', 0.0)
            growth_rate = data.get('growth_rate', 0.0)
            temp = data.get('temperature', 37.0)
            
            # Log status
            self._log.info(
                f"Vial {vial}: OD={od:.3f}, Drug={drug_conc:.1f}, "
                f"Growth Rate={growth_rate:.3f}/hr"
            )
            
            # Save to database if app context is available
            if self.app and self.db and self.measurement_model and hasattr(self.experiment, 'model'):
                try:
                    with self.app.app_context():
                        measurement = self.measurement_model(
                            experiment_id=self.experiment.model.id,
                            vial=vial,
                            timestamp=datetime.now(),
                            od=od,
                            temperature=temp,
                            drug_concentration=drug_conc,
                            growth_rate=growth_rate
                        )
                        self.db.session.add(measurement)
                        self.db.session.commit()
                        self._log.debug(f"Saved measurement for vial {vial} to database")
                except Exception as e:
                    self._log.error(f"Failed to save measurement to database: {str(e)}")
            
            # Record measurement in data logger
            self.data_logger.log_measurement(
                vial=vial,
                od=od,
                temperature=temp,
                drug_concentration=drug_conc,
                growth_rate=growth_rate,
                action=data.get('last_action')
            )
        
        if status.get('error'):
            self._log.error(f"Experiment error: {status['error']}")
            self.data_logger.log_event('error', {'message': status['error']})


--- simulation/src/replifactory_simulation/simulation_factory.py ---
from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface
)
from replifactory_core.base_device import BaseDevice, BaseDeviceConfig
from replifactory_core.factory import DeviceComponentFactory

from .devices import (
    SimulatedPump, SimulatedValves, SimulatedStirrer,
    SimulatedODSensor, SimulatedThermometer
)


class SimulationFactory(DeviceComponentFactory):
    def create_pump(self, pump_number: int) -> PumpInterface:
        return SimulatedPump(pump_number=pump_number)
    
    def create_valves(self) -> ValveInterface:
        return SimulatedValves()
    
    def create_stirrer(self) -> StirrerInterface:
        return SimulatedStirrer()
    
    def create_od_sensor(self) -> ODSensorInterface:
        return SimulatedODSensor()
    
    def create_thermometer(self) -> ThermometerInterface:
        return SimulatedThermometer()


def create_simulated_device(config: BaseDeviceConfig = None) -> BaseDevice:
    if config is None:
        config = BaseDeviceConfig()
    
    factory = SimulationFactory()
    
    pumps = {
        1: factory.create_pump(1),  # Media
        2: factory.create_pump(2),  # Drug
        4: factory.create_pump(4)   # Waste
    }
    
    return BaseDevice(
        config=config,
        pumps=pumps,
        valves=factory.create_valves(),
        stirrer=factory.create_stirrer(),
        od_sensor=factory.create_od_sensor(),
        thermometer=factory.create_thermometer()
    )

--- simulation/tests/simple_test.py ---
import pytest
import numpy as np
from replifactory_core.base_device import BaseDeviceConfig
from replifactory_simulation.simulation_factory import create_simulated_device
from replifactory_core.interfaces import DeviceError, StirrerSpeed




@pytest.fixture
def device():
    return create_simulated_device()


def test_device_creation():
    device = create_simulated_device()
    assert device is not None
    
    # Check required components exist
    assert 1 in device._pumps  # Media pump
    assert 2 in device._pumps  # Drug pump
    assert 4 in device._pumps  # Waste pump
    assert device._valves is not None
    assert device._stirrer is not None
    assert device._od_sensor is not None
    assert device._thermometer is not None


def test_vial_measurements(device):
    # Test valid measurement
    measurements = device.measure_vial(1)
    assert measurements.od >= 0
    assert 20 <= measurements.temperature <= 45  # Reasonable temp range
    assert measurements.rpm is not None
    
    # Test invalid vial number
    with pytest.raises(ValueError):
        device.measure_vial(8)
    with pytest.raises(ValueError):
        device.measure_vial(0)


def test_dilution_operation(device):
    # Valid dilution
    device.make_dilution(1, media_volume=5.0, drug_volume=0.5)
    
    # Test volume limits
    with pytest.raises(ValueError):
        device.make_dilution(1, media_volume=50.0, drug_volume=0.5)  # Too much volume
        
    # Test invalid vial
    with pytest.raises(ValueError):
        device.make_dilution(8, media_volume=5.0, drug_volume=0.5)


def test_pump_behavior(device):
    pump = device._pumps[1]
    
    # Test pumping
    initial_volume = pump.pumped_volume
    test_volume = 5.0
    pump.pump(test_volume)
    assert pump.pumped_volume == initial_volume + test_volume
    assert not pump.is_pumping
    
    # Test concurrent pumping prevention
    with pytest.raises(DeviceError):
        pump.pump(1.0)
        pump.pump(1.0)  # Should fail - pump busy


def test_valve_operations(device):
    valves = device._valves
    
    # Test open/close
    valves.open(1)
    assert valves.is_open(1)
    valves.close(1)
    assert not valves.is_open(1)
    
    # Test close_all
    valves.open(1)
    valves.open(2)
    valves.close_all()
    assert not any(valves.is_open(v) for v in range(1, 8))


def test_stirrer_control(device):
    stirrer = device._stirrer
    
    # Test speed setting
    stirrer.set_speed(1, StirrerSpeed.HIGH)
    rpm = stirrer.measure_rpm(1)
    assert rpm > 0
    
    stirrer.set_speed(1, StirrerSpeed.STOPPED)
    rpm = stirrer.measure_rpm(1)
    assert rpm == 0
    
    # Test emergency stop
    stirrer.set_speed(1, StirrerSpeed.HIGH)
    stirrer.stop_all()
    rpm = stirrer.measure_rpm(1)
    assert rpm == 0


def test_od_sensor(device):
    sensor = device._od_sensor
    
    # Test OD measurement
    od, signal = sensor.measure_od(1)
    assert od >= 0
    assert signal > 0
    
    # Test blank measurement
    blank = sensor.measure_blank(1)
    assert blank > 0


def test_temperature_monitoring(device):
    temps = device._thermometer.measure_temperature()
    
    assert 'vials' in temps
    assert 'board' in temps
    assert 20 <= temps['vials'] <= 45
    assert 20 <= temps['board'] <= 45


def test_vial_status(device):
    status = device.vial_status
    
    # Check all vials present
    assert all(v in status for v in range(1, 8))
    
    # Check required measurements
    for v in range(1, 8):
        assert 'od' in status[v]
        assert 'temperature' in status[v]
        assert 'rpm' in status[v]


def test_emergency_stop(device):
    # Set up some activity
    device._valves.open(1)
    device._stirrer.set_speed(1, StirrerSpeed.HIGH)
    
    # Emergency stop
    device.emergency_stop()
    
    # Verify everything stopped
    assert not device._valves.is_open(1)
    assert device._stirrer.measure_rpm(1) == 0
    assert not any(pump.is_pumping for pump in device._pumps.values())


def test_growth_simulation(device):
    # Initial measurement
    m1 = device.measure_vial(1)
    initial_od = m1.od
    
    # Make dilution and verify OD decreases
    device.make_dilution(1, media_volume=5.0, drug_volume=0.0)
    m2 = device.measure_vial(1)
    assert m2.od < initial_od
    
    # Add drug and verify growth impact
    device.make_dilution(1, media_volume=0.0, drug_volume=5.0)
    m3 = device.measure_vial(1)
    status = device.vial_status

--- ui/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Replifactory Monitor</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .status-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }
        .status-connected {
            background-color: #d4edda;
            color: #155724;
        }
        .status-disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status-connecting {
            background-color: #fff3cd;
            color: #856404;
        }
        .vials-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .vial-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .vial-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .vial-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .measurement {
            margin: 5px 0;
            color: #34495e;
        }
        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        .chart-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: 400px;
        }
        .no-data {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Replifactory Monitor</h1>
            <div id="connection-status" class="status-indicator status-connecting">
                Connecting to server...
            </div>
        </div>
        <div id="no-data" class="no-data">Waiting for experiment data...</div>
        <div class="vials-container" id="vials"></div>
        <div class="charts-container">
            <div class="chart-card">
                <canvas id="odChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Initialize Socket.IO connection
        const socket = io('http://localhost:5000', {
            transports: ['websocket', 'polling'],
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: 10
        });
        const statusElement = document.getElementById('connection-status');
        const noDataElement = document.getElementById('no-data');
        
        // Initialize data structures
        let vialData = {};
        let timeSeriesData = {};
        let odChart;
        
        // Add function to get active experiment
        async function getActiveExperiment() {
            try {
                console.log('Fetching active experiment...');
                const response = await fetch('http://localhost:5000/experiments/active', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Active experiment data:', data);
                
                if (data.experiment) {
                    console.log('Active experiment:', data.experiment);
                    noDataElement.textContent = `Monitoring experiment ${data.experiment.id}: ${data.experiment.name}`;
                    initializeChart();
                } else {
                    console.log('No active experiment found');
                    noDataElement.textContent = 'No active experiment';
                }
            } catch (error) {
                console.error('Error fetching active experiment:', error);
                noDataElement.textContent = 'Error fetching experiment info';
                statusElement.className = 'status-indicator status-disconnected';
                statusElement.textContent = `Connection error: ${error.message}`;
            }
        }
        
        // Call on page load and socket reconnect
        document.addEventListener('DOMContentLoaded', getActiveExperiment);
        socket.on('connect', getActiveExperiment);
        
        // Initialize Chart.js
        function initializeChart() {
            console.log('Initializing chart...');
            // Destroy existing chart if it exists
            if (odChart) {
                console.log('Destroying existing chart');
                odChart.destroy();
            }

            const ctx = document.getElementById('odChart').getContext('2d');
            odChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    animation: false,
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'OD Measurements Over Time',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm:ss'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                source: 'auto',
                                autoSkip: true
                            },
                            min: undefined,
                            max: undefined
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'OD'
                            },
                            suggestedMin: 0,
                            suggestedMax: 0.2
                        }
                    }
                }
            });
            
            // Clear existing time series data
            timeSeriesData = {};
            console.log('Chart initialized');
        }
        
        // Handle vial updates
        socket.on('vial_update', (data) => {
            console.log('Received vial update:', data);
            const vialId = data.vial;
            
            // Initialize time series data for new vials
            if (!timeSeriesData[vialId]) {
                console.log(`Initializing dataset for vial ${vialId}`);
                timeSeriesData[vialId] = [];
                odChart.data.datasets.push({
                    label: `Vial ${vialId}`,
                    data: timeSeriesData[vialId],
                    borderColor: `hsl(${vialId * 137.5}, 70%, 50%)`,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 3
                });
                console.log(`Added new dataset:`, odChart.data.datasets[odChart.data.datasets.length - 1]);
            }
            
            // Add new data point
            const newPoint = {
                x: new Date(data.timestamp),
                y: parseFloat(data.od)
            };
            console.log(`Adding point for vial ${vialId}:`, newPoint);
            timeSeriesData[vialId].push(newPoint);
            
            // Sort data points by timestamp
            timeSeriesData[vialId].sort((a, b) => a.x - b.x);
            
            // Update chart datasets
            odChart.data.datasets.forEach((dataset, index) => {
                if (dataset.label === `Vial ${vialId}`) {
                    dataset.data = [...timeSeriesData[vialId]]; // Create new array reference
                    console.log(`Updated dataset ${dataset.label}:`, dataset.data);
                }
            });
            
            // Update chart axes
            const allDates = Object.values(timeSeriesData)
                .flat()
                .map(point => point.x);
            if (allDates.length > 0) {
                const minDate = new Date(Math.min(...allDates));
                const maxDate = new Date(Math.max(...allDates));
                odChart.options.scales.x.min = minDate;
                odChart.options.scales.x.max = maxDate;
            }
            
            // Force chart update
            odChart.update('none');
            console.log('Chart updated');
            
            // Update vial display
            updateVialDisplay(data);
        });
        
        // Update vial display
        function updateVialDisplay(data) {
            const vialId = data.vial;
            vialData[vialId] = data;
            
            // Hide no-data message if we have data
            noDataElement.style.display = 'none';
            
            // Update or create vial card
            let vialElement = document.getElementById(`vial-${vialId}`);
            if (!vialElement) {
                vialElement = document.createElement('div');
                vialElement.id = `vial-${vialId}`;
                vialElement.className = 'vial-card';
                document.getElementById('vials').appendChild(vialElement);
            }
            
            vialElement.innerHTML = `
                <div class="vial-title">Vial ${vialId}</div>
                <div class="measurement">OD: ${data.od.toFixed(3)}</div>
                <div class="measurement">Temperature: ${data.temperature.toFixed(1)}°C</div>
                ${data.drug_concentration !== null ? 
                    `<div class="measurement">Drug Concentration: ${data.drug_concentration.toFixed(2)}</div>` : ''}
                ${data.growth_rate !== null ? 
                    `<div class="measurement">Growth Rate: ${data.growth_rate.toFixed(3)}/hr</div>` : ''}
                <div class="measurement">Last Update: ${new Date(data.timestamp).toLocaleTimeString()}</div>
            `;
        }
        
        // Socket.IO event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            statusElement.className = 'status-indicator status-connected';
            statusElement.textContent = 'Connected to server';
            getActiveExperiment();
        });
        
        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            statusElement.className = 'status-indicator status-disconnected';
            statusElement.textContent = `Connection error: ${error.message}`;
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            statusElement.className = 'status-indicator status-disconnected';
            statusElement.textContent = 'Disconnected from server';
        });
        
        socket.on('reconnecting', (attemptNumber) => {
            console.log(`Attempting to reconnect (${attemptNumber})`);
            statusElement.className = 'status-indicator status-connecting';
            statusElement.textContent = `Reconnecting (attempt ${attemptNumber})...`;
        });
    </script>
</body>
</html> 

--- ui/pyproject.toml ---


--- ui/serve.py ---
from http.server import HTTPServer, SimpleHTTPRequestHandler
import os
import sys

def run(port=8000):
    """Run the HTTP server on the specified port."""
    server_address = ('', port)
    httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
    print(f"Starting UI server on port {port}")
    print(f"Open http://localhost:{port} in your browser")
    httpd.serve_forever()

if __name__ == '__main__':
    # Change to the directory containing this script
    os.chdir(os.path.dirname(os.path.abspath(__file__)))
    
    # Get port from command line argument or use default
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
    run(port) 

--- ui/tests/.gitkeep ---

