Repository: replifactory

File Tree:
└── .gitignore
└── README.md
└── core/pyproject.toml
└── core/src/replifactory_core/__init__.py
└── core/src/replifactory_core/base_device.py
└── core/src/replifactory_core/culture.py
└── core/src/replifactory_core/experiment.py
└── core/src/replifactory_core/factory.py
└── core/src/replifactory_core/interfaces.py
└── core/src/replifactory_core/parameters.py
└── core/src/replifactory_core/protocols.py
└── core/src/replifactory_core/types.py
└── core/tests/.gitkeep
└── docs/developer-guide/.gitkeep
└── docs/index.md
└── docs/user-guide/.gitkeep
└── hardware/pyproject.toml
└── hardware/tests/.gitkeep
└── mkdocs.yml
└── nx.json
└── pyproject.toml
└── server/pyproject.toml
└── server/requirements.txt
└── server/src/replifactory_server/.gitkeep
└── server/src/replifactory_server/create_experiment.py
└── server/src/replifactory_server/database.py
└── server/src/replifactory_server/database_models.py
└── server/src/replifactory_server/init.py
└── server/src/replifactory_server/init_db.py
└── server/src/replifactory_server/models.py
└── server/src/replifactory_server/monitor.py
└── server/src/replifactory_server/routes.py
└── server/src/replifactory_server/server.py
└── server/src/replifactory_server/start_experiment.py
└── server/src/replifactory_server/start_server.py
└── server/tests/.gitkeep
└── simulation/examples/quick_start.py
└── simulation/examples/run_simulation.py
└── simulation/pyproject.toml
└── simulation/src/replifactory_simulation/.gitkeep
└── simulation/src/replifactory_simulation/__init__.py
└── simulation/src/replifactory_simulation/devices.py
└── simulation/src/replifactory_simulation/growth_model.py
└── simulation/src/replifactory_simulation/logging.py
└── simulation/src/replifactory_simulation/runner.py
└── simulation/src/replifactory_simulation/simulation_factory.py
└── simulation/tests/.gitkeep
└── simulation/tests/simple_test.py
└── tools/gitkeep_dirs.py
└── ui/index.html
└── ui/pyproject.toml
└── ui/serve.py
└── ui/tests/.gitkeep

File Contents:

--- .gitignore ---
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# PyPI configuration file
.pypirc


# Project-specific
misc/
old_version/
simulation_logs/
context.txt

# Flask instance folder
instance/

# Database files
*.db
*.db-journal
data/

# Docker files
*.log
*.log.*

--- README.md ---
# replifactory

--- core/pyproject.toml ---
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "replifactory-core"
version = "0.1.0"
description = "Core components for the Replifactory bacterial evolution system"
authors = [
    { name = "Replifactory Team" }
]
readme = "README.md"
requires-python = ">=3.10"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dependencies = [
    "numpy>=1.21.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/replifactory_core"]

[project.urls]
"Homepage" = "https://github.com/yourusername/replifactory"
"Bug Tracker" = "https://github.com/yourusername/replifactory/issues"


--- core/src/replifactory_core/__init__.py ---


--- core/src/replifactory_core/base_device.py ---
from dataclasses import dataclass
from typing import Dict, Optional

import numpy as np 
import logging

logger = logging.getLogger(__name__)

from .interfaces import (
    ExperimentDeviceInterface,
    PumpInterface,
    ValveInterface,
    StirrerInterface,
    ODSensorInterface,
    ThermometerInterface,
    VialMeasurements,
    DeviceError
)

from .parameters import *


@dataclass
class BaseDeviceConfig:
    """Configuration for BaseDevice.
    
    Attributes:
        n_vials: Number of vials in device
        max_volume_ml: Maximum vial volume in ml
        min_volume_ml: Minimum operating volume in ml
    """
    n_vials: int = 7
    max_volume_ml: float = 30.0
    min_volume_ml: float = 5.0


class BaseDevice(ExperimentDeviceInterface):
    """Base implementation of experiment device control.
    
    Coordinates multiple device components to perform experiment operations.
    All hardware-specific implementation is delegated to injected components.
    
    Args:
        config: Device configuration
        pumps: Dict mapping pump numbers to pump interfaces
        valves: Valve control interface
        stirrer: Stirrer control interface
        od_sensor: OD measurement interface
        thermometer: Temperature measurement interface
    """
    
    def __init__(
        self,
        config: BaseDeviceConfig,
        pumps: Dict[int, PumpInterface],
        valves: ValveInterface,
        stirrer: StirrerInterface,
        od_sensor: ODSensorInterface,
        thermometer: ThermometerInterface,
    ):
        self.config = config
        self._pumps = pumps
        self._valves = valves
        self._stirrer = stirrer
        self._od_sensor = od_sensor
        self._thermometer = thermometer
        
        # Validate configuration
        self._validate_components()

    def _validate_components(self) -> None:
        """Validate device configuration and components.
        
        Raises:
            ValueError: If configuration is invalid
            DeviceError: If components are missing or misconfigured
        """
        if not (1 <= self.config.n_vials <= 7):
            raise ValueError(f"Invalid number of vials: {self.config.n_vials}")
            
        required_pumps = {1, 2, 4}  # Media, drug, waste
        if not all(p in self._pumps for p in required_pumps):
            raise DeviceError(f"Missing required pumps: {required_pumps - set(self._pumps)}")

    def measure_vial(self, vial: int) -> VialMeasurements:
        logger.debug(f"Starting measurement for vial {vial}")
        if not 1 <= vial <= self.config.n_vials:
            raise ValueError(f"Invalid vial number: {vial}")
            
        try:
            # Set stirrer to measurement speed
            logger.debug("Setting stirrer to low speed")
            self._stirrer.set_speed(vial, "low")
            
            # Take measurements
            logger.debug("Taking OD measurement")
            od, signal = self._od_sensor.measure_od(vial)
            logger.debug(f"OD measurement complete: {od:.3f}")
            
            logger.debug("Taking temperature measurement")
            temp = self._thermometer.measure_temperature()['vials']
            logger.debug(f"Temperature measurement complete: {temp:.1f}")
            
            logger.debug("Measuring RPM")
            rpm = self._stirrer.measure_rpm(vial)
            logger.debug(f"RPM measurement complete: {rpm}")
            
            # Restore stirrer speed
            logger.debug("Restoring stirrer to high speed")
            self._stirrer.set_speed(vial, "high")
            
            measurements = VialMeasurements(
                od=od,
                temperature=temp,
                rpm=rpm
            )
            logger.debug(f"Measurement complete for vial {vial}: {measurements}")
            return measurements
            
        except Exception as e:
            # Ensure stirrer restored on error
            logger.error(f"Error during measurement: {str(e)}")
            self._stirrer.set_speed(vial, "high")
            raise DeviceError(f"Measurement failed: {str(e)}")

    def make_dilution(self, vial: int, media_volume: float, drug_volume: float) -> None:
        """Perform dilution operation on specific vial.
        
        Args:
            vial: Vial number (1-7)
            media_volume: Volume of fresh media to add in ml
            drug_volume: Volume of drug solution to add in ml
            
        Raises:
            ValueError: If parameters invalid
            DeviceError: If operation fails
        """
        if not 1 <= vial <= self.config.n_vials:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Validate volumes
        total_volume = media_volume + drug_volume
        if total_volume > self.config.max_volume_ml:
            raise ValueError(f"Total volume {total_volume} exceeds maximum {self.config.max_volume_ml}")
            
        try:
            # Calculate new drug concentration
            current_volume = 12.0  # TODO: Get from config
            total_volume = current_volume + media_volume + drug_volume
            
            if hasattr(self._od_sensor, 'update_drug_concentration'):
                new_concentration = (drug_volume / total_volume) * 100.0  # Assuming 100x stock
                self._od_sensor.update_drug_concentration(vial, new_concentration)
            
            # Remove waste volume
            self._valves.open(vial)
            self._pumps[4].pump(total_volume)  # Waste pump
            
            # Add fresh media
            if media_volume > 0:
                self._pumps[1].pump(media_volume)  # Media pump
                
            # Add drug
            if drug_volume > 0:
                self._pumps[2].pump(drug_volume)  # Drug pump
                
        except Exception as e:
            self.emergency_stop()
            raise DeviceError(f"Dilution failed: {str(e)}")
            
        finally:
            self._valves.close(vial)

    def emergency_stop(self) -> None:
        """Emergency stop all device operations."""
        try:
            # Stop all moving parts
            for pump in self._pumps.values():
                pump.stop()
            self._stirrer.stop_all()
            
            # Close all valves
            self._valves.close_all()
            
        except Exception as e:
            # Log but don't raise - must try all stop operations
            print(f"Error during emergency stop: {str(e)}")

    @property
    def vial_status(self) -> Dict[int, Dict[str, float]]:
        """Get current status of all vials."""
        status = {}
        for vial in range(1, self.config.n_vials + 1):
            try:
                measurements = self.measure_vial(vial)
                status[vial] = {
                    'od': measurements.od,
                    'temperature': measurements.temperature,
                    'rpm': measurements.rpm if measurements.rpm else 0.0
                }
            except Exception as e:
                # Include error indication in status
                status[vial] = {
                    'od': -1.0,
                    'temperature': -1.0,
                    'rpm': -1.0,
                    'error': str(e)
                }
        return status

    def activate_pump(self, pump_id: int, volume: float) -> None:
        """Activate a pump to dispense the specified volume.
        
        Args:
            pump_id: The pump number to activate
            volume: Volume to pump in mL
            
        Raises:
            ValueError: If pump_id is invalid
            DeviceError: If pump operation fails
        """
        if pump_id not in self._pumps:
            raise ValueError(f"Invalid pump number: {pump_id}")
            
        try:
            self._pumps[pump_id].pump(volume)
        except Exception as e:
            raise DeviceError(f"Pump operation failed: {str(e)}")

    def set_valve_state(self, valve_id: int, state: bool) -> None:
        """Set the state of a valve.
        
        Args:
            valve_id: The valve number to control
            state: True to open, False to close
            
        Raises:
            ValueError: If valve_id is invalid
            DeviceError: If valve operation fails
        """
        if not 1 <= valve_id <= self.config.n_vials:
            raise ValueError(f"Invalid valve number: {valve_id}")
            
        try:
            if state:
                self._valves.open(valve_id)
            else:
                self._valves.close(valve_id)
        except Exception as e:
            raise DeviceError(f"Valve operation failed: {str(e)}")

--- core/src/replifactory_core/culture.py ---
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import numpy as np

from .parameters import VialMeasurements
from .base_device import BaseDevice

@dataclass
class CultureConfig:
    """Configuration for bacterial culture control.
    
    Attributes:
        od_threshold: OD level that triggers dilution
        growth_rate_threshold: Growth rate that triggers stress increase
        min_growth_rate: Growth rate below which rescue dilution occurs
        dilution_factor: Factor by which to dilute culture
        max_drug_concentration: Maximum allowed drug concentration
    """
    od_threshold: float = 0.3
    growth_rate_threshold: float = 0.15
    min_growth_rate: float = -0.1
    dilution_factor: float = 1.6
    max_drug_concentration: float = 100.0

class Culture:
    """Core culture control logic.
    
    Manages a single bacterial culture vial, coordinating measurements,
    growth tracking, and drug concentration adjustments.
    
    Args:
        vial: Vial number (1-7)
        device: Device interface for hardware control
        config: Culture control parameters
    """
    
    def __init__(
        self,
        vial: int,
        device: BaseDevice,
        config: CultureConfig = CultureConfig()
    ):
        self.vial = vial
        self._device = device
        self.config = config
        
        self._measurements: List[Tuple[datetime, VialMeasurements]] = []
        self._drug_concentrations: List[Tuple[datetime, float]] = []
        self._generations: List[Tuple[datetime, float]] = []
        
        # Initialize with zero drug concentration
        self._drug_concentrations.append((datetime.now(), 0.0))
        self._generations.append((datetime.now(), 0.0))

    def measure(self) -> VialMeasurements:
        """Take new measurements of the culture.
        
        Returns:
            VialMeasurements containing current culture state
            
        Raises:
            DeviceError: If measurements fail
        """
        measurements = self._device.measure_vial(self.vial)
        self._measurements.append((datetime.now(), measurements))
        return measurements

    def calculate_growth_rate(self, window_minutes: int = 30) -> Optional[float]:
        """Calculate current growth rate from recent measurements.
        
        Args:
            window_minutes: Time window to use for calculation
            
        Returns:
            Growth rate in 1/hour or None if insufficient data
        """
        if len(self._measurements) < 2:
            return None
            
        # Get measurements in window
        now = datetime.now()
        window_measurements = [
            (t, m) for t, m in self._measurements 
            if (now - t).total_seconds() <= window_minutes * 60
        ]
        
        if len(window_measurements) < 2:
            return None
            
        # Calculate growth rate from OD measurements
        t1, m1 = window_measurements[0]
        t2, m2 = window_measurements[-1]
        
        dt = (t2 - t1).total_seconds() / 3600  # Convert to hours
        if dt == 0:
            return None
            
        return (np.log(m2.od) - np.log(m1.od)) / dt

    def make_dilution(self, target_drug_concentration: Optional[float] = None) -> None:
        """Perform dilution with optional drug concentration adjustment.
        
        Args:
            target_drug_concentration: Desired final drug concentration.
                If None, maintains current concentration.
                
        Raises:
            ValueError: If target concentration exceeds maximum
            DeviceError: If dilution operation fails
        """
        if target_drug_concentration is None:
            target_drug_concentration = self._drug_concentrations[-1][1]
            
        if target_drug_concentration > self.config.max_drug_concentration:
            raise ValueError(f"Target concentration {target_drug_concentration} exceeds maximum {self.config.max_drug_concentration}")
            
        # Calculate volumes needed
        current_volume = 12.0  # TODO: Get from device config
        added_volume = current_volume * (self.config.dilution_factor - 1)
        
        # Calculate media and drug volumes to achieve target concentration
        if target_drug_concentration > 0:
            drug_volume = added_volume * (target_drug_concentration / self.config.max_drug_concentration)
            media_volume = added_volume - drug_volume
        else:
            drug_volume = 0
            media_volume = added_volume
            
        # Perform dilution
        self._device.make_dilution(self.vial, media_volume, drug_volume)
        
        # Update tracking
        now = datetime.now()
        self._drug_concentrations.append((now, target_drug_concentration))
        
        # Update generations
        prev_gens = self._generations[-1][1]
        new_gens = prev_gens + np.log2(self.config.dilution_factor)
        self._generations.append((now, new_gens))

    @property
    def current_od(self) -> Optional[float]:
        """Get most recent OD measurement."""
        if not self._measurements:
            return None
        return self._measurements[-1][1].od
        
    @property
    def current_drug_concentration(self) -> float:
        """Get current drug concentration."""
        return self._drug_concentrations[-1][1]
        
    @property
    def generations(self) -> float:
        """Get current number of generations."""
        return self._generations[-1][1]
        
    @property
    def status(self) -> Dict:
        """Get current culture status."""
        return {
            'od': self.current_od,
            'drug_concentration': self.current_drug_concentration,
            'generations': self.generations,
            'growth_rate': self.calculate_growth_rate(),
            'last_measurement': self._measurements[-1][0] if self._measurements else None
        } 

--- core/src/replifactory_core/experiment.py ---
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional
import json

from .culture import Culture, CultureConfig
from .base_device import BaseDevice, BaseDeviceConfig
from .interfaces import DeviceError
from .protocols import GrowthControlProtocol, MorbidostatProtocol, MorbidostatConfig

@dataclass
class ExperimentConfig:
    """Configuration for experiment control.
    
    Attributes:
        measurement_interval_mins: Time between measurements
        max_generations: Stop experiment after this many generations
        max_duration_hours: Stop experiment after this many hours
        culture_config: Configuration applied to all cultures
        device_config: Device configuration
    """
    measurement_interval_mins: int = 10
    max_generations: Optional[float] = None
    max_duration_hours: Optional[float] = None
    culture_config: CultureConfig = CultureConfig()
    device_config: BaseDeviceConfig = BaseDeviceConfig()

class Experiment:
    """Coordinates multiple bacterial cultures in an evolution experiment.
    
    Manages multiple cultures, scheduling measurements and dilutions
    according to the experimental protocol.
    
    Args:
        device: Device interface for hardware control
        config: Experiment parameters
        name: Optional experiment identifier
    """
    
    def __init__(
        self,
        device: BaseDevice,
        config: ExperimentConfig = ExperimentConfig(),
        name: Optional[str] = None,
        protocol: Optional[GrowthControlProtocol] = None
    ):
        self.name = name or datetime.now().strftime("%Y%m%d_%H%M%S")
        self.config = config
        self._device = device
        self._start_time = datetime.now()
        
        # Initialize protocol
        self.protocol = protocol or MorbidostatProtocol(MorbidostatConfig())
        
        # Initialize cultures
        self.cultures: Dict[int, Culture] = {}
        for vial in range(1, self.config.device_config.n_vials + 1):
            self.cultures[vial] = Culture(
                vial=vial,
                device=device,
                config=config.culture_config
            )
        
        self._status = "initialized"
        self._error: Optional[str] = None
        
    def start(self) -> None:
        """Start the experiment.
        
        Initializes all cultures and begins measurement cycle.
        
        Raises:
            DeviceError: If device initialization fails
            RuntimeError: If experiment already running
        """
        if self._status == "running":
            raise RuntimeError("Experiment already running")
            
        try:
            # Take initial measurements
            for culture in self.cultures.values():
                culture.measure()
                
            self._status = "running"
            self._start_time = datetime.now()
            self._error = None
            
        except Exception as e:
            self._status = "error"
            self._error = str(e)
            raise

    def stop(self) -> None:
        """Stop the experiment.
        
        Stops all device operations and sets experiment to stopped state.
        """
        try:
            self._device.emergency_stop()
        except DeviceError as e:
            self._error = f"Error during stop: {str(e)}"
            
        self._status = "stopped"

    def pause(self) -> None:
        """Pause the experiment.
        
        Temporarily suspends operations while maintaining state.
        """
        if self._status != "running":
            raise RuntimeError(f"Cannot pause experiment in {self._status} state")
            
        self._status = "paused"

    def resume(self) -> None:
        """Resume a paused experiment."""
        if self._status != "paused":
            raise RuntimeError(f"Cannot resume experiment in {self._status} state")
            
        self._status = "running"

    def update(self) -> None:
        """Perform one update cycle using configured protocol."""
        if self._status != "running":
            return
        
        try:
            # Update each culture using protocol
            for culture in self.cultures.values():
                self.protocol.update(culture)
                
            self._check_end_conditions()
                
        except Exception as e:
            self._status = "error"
            self._error = str(e)
            raise

    def _check_end_conditions(self) -> None:
        """Check if experiment should end based on config."""
        if self.config.max_generations:
            max_gens = max(c.generations for c in self.cultures.values())
            if max_gens >= self.config.max_generations:
                self.stop()
                
        if self.config.max_duration_hours:
            duration = (datetime.now() - self._start_time).total_seconds() / 3600
            if duration >= self.config.max_duration_hours:
                self.stop()

    @property
    def status(self) -> Dict:
        """Get current experiment status."""
        return {
            'name': self.name,
            'status': self._status,
            'error': self._error,
            'start_time': self._start_time.isoformat(),
            'duration_hours': (datetime.now() - self._start_time).total_seconds() / 3600,
            'cultures': {
                vial: culture.status 
                for vial, culture in self.cultures.items()
            }
        }

    def save_state(self, filename: str) -> None:
        """Save experiment state to file.
        
        Args:
            filename: Path to save state file
        """
        state = {
            'name': self.name,
            'config': self.config.__dict__,
            'status': self.status,
            'timestamp': datetime.now().isoformat()
        }
        
        with open(filename, 'w') as f:
            json.dump(state, f, indent=2)

    @classmethod
    def load_state(cls, filename: str, device: BaseDevice) -> 'Experiment':
        """Load experiment from saved state.
        
        Args:
            filename: Path to state file
            device: Device interface to use
            
        Returns:
            Reconstructed Experiment instance
        """
        with open(filename) as f:
            state = json.load(f)
            
        config = ExperimentConfig(**state['config'])
        exp = cls(device=device, config=config, name=state['name'])
        
        # Restore status
        exp._status = state['status']['status']
        exp._error = state['status']['error']
        exp._start_time = datetime.fromisoformat(state['status']['start_time'])
        
        return exp 

--- core/src/replifactory_core/factory.py ---
from abc import ABC, abstractmethod
from typing import Dict

from .interfaces import (
    PumpInterface,
    ValveInterface,
    StirrerInterface,
    ODSensorInterface,
    ThermometerInterface
)
from .base_device import BaseDevice, BaseDeviceConfig


class DeviceComponentFactory(ABC):
    """Abstract factory for creating device components.
    
    Provides interface for creating all device components.
    Concrete implementations create either real or simulated components.
    """
    
    @abstractmethod
    def create_pump(self, pump_number: int) -> PumpInterface:
        """Create a pump component.
        
        Args:
            pump_number: Identifier for the pump (1=media, 2=drug, 4=waste)
        """
        pass
    
    @abstractmethod
    def create_valves(self) -> ValveInterface:
        """Create valve control component."""
        pass
    
    @abstractmethod
    def create_stirrer(self) -> StirrerInterface:
        """Create stirrer control component."""
        pass
    
    @abstractmethod
    def create_od_sensor(self) -> ODSensorInterface:
        """Create OD measurement component."""
        pass
    
    @abstractmethod
    def create_thermometer(self) -> ThermometerInterface:
        """Create temperature measurement component."""
        pass


class DeviceFactory:
    """Factory for creating complete device instances.
    
    Creates and assembles all components into a working device.
    """
    
    @staticmethod
    def create_device(
        factory: DeviceComponentFactory,
        config: BaseDeviceConfig = BaseDeviceConfig()
    ) -> BaseDevice:
        """Create a complete device using specified component factory.
        
        Args:
            factory: Component factory (real or simulated)
            config: Device configuration
            
        Returns:
            Configured BaseDevice instance
        """
        # Create required pumps
        pumps: Dict[int, PumpInterface] = {
            1: factory.create_pump(1),  # Media pump
            2: factory.create_pump(2),  # Drug pump
            4: factory.create_pump(4)   # Waste pump
        }
        
        # Create other components
        valves = factory.create_valves()
        stirrer = factory.create_stirrer()
        od_sensor = factory.create_od_sensor()
        thermometer = factory.create_thermometer()
        
        # Assemble device
        return BaseDevice(
            config=config,
            pumps=pumps,
            valves=valves,
            stirrer=stirrer,    
            od_sensor=od_sensor,
            thermometer=thermometer
        )


--- core/src/replifactory_core/interfaces.py ---
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Dict, Optional, Tuple, List

from .parameters import *


class DeviceError(Exception):
    """Base exception for device-related errors."""
    pass


class StirrerSpeed(str, Enum):
    """Enumeration of valid stirrer speeds.
    
    STOPPED: Motor off
    LOW: Low speed for measurement
    HIGH: Normal operating speed
    """
    STOPPED = "stopped"
    LOW = "low"
    HIGH = "high"


class PumpInterface(ABC):
    """Interface for controlling fluid pumps in the device.
    
    Provides high-level control of pumping operations while abstracting away
    hardware details like stepper motors or peristaltic mechanisms.
    
    A pump must maintain accurate volume tracking and provide immediate
    stop capability for safety.
    
    Typical usage:
        pump.pump(5.0)  # Pump 5ml
        if pump.is_pumping:
            pump.stop()  # Emergency stop
    """
    
    @abstractmethod
    def pump(self, volume_ml: float) -> None:
        """Pump a specific volume of fluid.
        
        Args:
            volume_ml: Volume to pump in milliliters. Positive values pump forward,
                      negative values pump in reverse if supported.
        
        Raises:
            ValueError: If volume exceeds pump parameters
            DeviceError: If pump operation fails
        
        Note:
            Method should block until pumping is complete unless stopped.
        """
        pass
    
    @abstractmethod
    def stop(self) -> None:
        """Immediately stop the pump.
        
        Emergency stop that halts the pump as quickly as possible without
        regard for completing the current operation.
        
        The pumped_volume property should reflect the actual delivered volume.
        
        Raises:
            DeviceError: If pump fails to stop
        """
        pass

    @property
    @abstractmethod
    def is_pumping(self) -> bool:
        """Check if pump is currently active.
        
        Returns:
            bool: True if pump is in operation, False if idle
            
        Note: 
            Should return True from the moment pump() is called until 
            the operation completes or is stopped.
        """
        pass

    @property
    @abstractmethod
    def pumped_volume(self) -> float:
        """Get total volume pumped since last reset.
        
        Returns:
            float: Cumulative volume in milliliters, including partial volumes
                  from stopped operations
                  
        Note:
            Tracking should continue across multiple pump operations until reset.
        """
        pass


class ValveInterface(ABC):
    """Interface for controlling liquid flow valves.
    
    Controls individual solenoid valves that direct fluid flow in the device.
    Each valve has a unique number and binary open/closed state.
    
    Valves are critical for fluid routing and provide safety isolation.
    All implementations must ensure reliable state reporting and 
    fail-closed behavior.
    
    Typical usage:
        valve.open(1)   # Open valve 1
        if valve.is_open(1):
            valve.close(1)
    """
    
    @abstractmethod
    def open(self, valve_number: int) -> None:
        """Open a specific valve.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Raises:
            ValueError: If valve_number is invalid (not 1-7)
            DeviceError: If valve fails to open or verify state
            
        Note:
            Method should block until valve is fully open and verified.
        """
        pass

    @abstractmethod
    def close(self, valve_number: int) -> None:
        """Close a specific valve.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Raises:
            ValueError: If valve_number is invalid
            DeviceError: If valve fails to close or verify state
            
        Note:
            Method must ensure valve is fully closed before returning.
            Should never fail to at least attempt closure for safety.
        """
        pass

    @abstractmethod
    def is_open(self, valve_number: int) -> bool:
        """Check if specific valve is open.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Returns:
            bool: True if valve is confirmed open, False if confirmed closed
            
        Raises:
            ValueError: If valve_number is invalid
            DeviceError: If valve state cannot be determined
            
        Note:
            Must return accurate state - if state cannot be verified,
            should raise DeviceError rather than guess.
        """
        pass

    @abstractmethod
    def close_all(self) -> None:
        """Close all valves immediately.
        
        Critical safety method - must attempt to close all valves even if
        some operations fail. Should be called in any error condition.
        
        Raises:
            DeviceError: If any valve fails to close. Error should include
                        information about which valves failed.
                        
        Note:
            Should make best effort to close all valves even after errors.
        """
        pass


class StirrerInterface(ABC):
    """Interface for controlling magnetic stirrers.
    
    Manages the stirring motors that mix cultures via magnetic stir bars.
    Supports variable speeds and rotation monitoring.
    
    Speed control is critical for:
    - Proper culture mixing
    - Accurate OD measurements (requires LOW speed)
    - Prevention of vortexing (speed limits)
    
    Implementation must ensure smooth speed transitions and
    accurate RPM reporting when available.
    
    Typical usage:
        stirrer.set_speed(1, StirrerSpeed.HIGH)  # Normal operation
        rpm = stirrer.measure_rpm(1)             # Check actual speed
        stirrer.set_speed(1, StirrerSpeed.LOW)   # Prepare for measurement
    """
    
    @abstractmethod
    def set_speed(self, vial: int, speed: StirrerSpeed) -> None:
        """Set stirrer speed for a specific vial.
        
        Args:
            vial: Vial number (1-7)
            speed: Desired stirring speed setting
            
        Raises:
            ValueError: If vial number invalid or speed not in StirrerSpeed
            DeviceError: If speed cannot be set or verified
            
        Note:
            Should transition smoothly between speeds to avoid splashing.
            Must verify speed change before returning.
        """
        pass
    
    @abstractmethod
    def measure_rpm(self, vial: int) -> float:
        """Measure current RPM for specific vial.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            float: Current stirring speed in rotations per minute
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If RPM cannot be measured
            
        Note:
            May return approximate RPM if exact measurement not possible.
            Should indicate measurement quality through error bounds.
        """
        pass

    @abstractmethod
    def stop_all(self) -> None:
        """Emergency stop all stirrers.
        
        Immediately stops all stirring motors. Used in emergency situations
        or during shutdown.
        
        Raises:
            DeviceError: If any stirrer fails to stop. Should still attempt
                        to stop all stirrers even after an error.
                        
        Note:
            Must attempt to stop all stirrers regardless of errors.
            Critical safety method.
        """
        pass


class ODSensorInterface(ABC):
    """Interface for optical density measurement system.
    
    Manages laser-based optical density measurements for monitoring bacterial growth.
    Coordinates laser control and photodiode readings to produce accurate OD values.
    
    Key responsibilities:
    - Accurate OD measurements
    - Blank calibration
    - Signal quality monitoring
    - Laser safety management
    
    Implementation must ensure:
    - Laser safety interlocks
    - Proper measurement timing
    - Signal stability checking
    - Background light compensation
    
    Typical usage:
        od, signal = sensor.measure_od(1)  # Get current OD
        blank = sensor.measure_blank(1)    # Calibration measurement
    """
    
    @abstractmethod
    def measure_od(self, vial: int, parameters: Optional[ODParameters] = None) -> Tuple[float, float]:
        """Measure optical density for specific vial.
        
        Performs a complete OD measurement cycle:
        1. Set stirrer to measurement speed
        2. Turn on laser
        3. Take photodiode reading
        4. Turn off laser
        5. Restore stirrer speed
        
        Args:
            vial: Vial number (1-7)
            parameters: Optional measurement parameters. Uses defaults if None.
            
        Returns:
            Tuple[float, float]: (od_value, signal_strength)
                od_value: Calculated optical density (relative to blank)
                signal_strength: Raw photodiode signal in millivolts
                
        Raises:
            ValueError: If vial number invalid
            DeviceError: If measurement fails (laser, photodiode, or signal quality)
            
        Note:
            Returns both OD and raw signal to allow signal quality assessment.
            Should verify signal stability before returning.
        """
        pass

    @abstractmethod
    def measure_blank(self, vial: int) -> float:
        """Measure blank/reference value for calibration.
        
        Takes reference measurement of clear media for OD calculation baseline.
        Must be called on each vial before experiment starts.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            float: Blank reading in millivolts
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If measurement fails or signal unstable
            
        Note:
            Should take multiple readings and verify stability.
            Critical for accurate OD measurements.
        """
        pass


class ThermometerInterface(ABC):
    """Interface for temperature monitoring system.
    
    Manages temperature sensors for both culture vials and control board.
    Temperature monitoring is critical for:
    - Culture growth conditions
    - Hardware protection
    - Safety cutoffs
    
    Implementation must provide reliable temperature data and
    proper error handling for sensor failures.
    
    Typical usage:
        temps = thermometer.measure_temperature()
        vial_temp = temps['vials']
        board_temp = temps['board']
    """
    
    @abstractmethod
    def measure_temperature(self) -> Dict[str, float]:
        """Measure all system temperatures.
        
        Returns:
            Dict[str, float]: Temperature readings in Celsius
                'vials': Average temperature of vial array
                'board': Control board temperature
                
        Raises:
            DeviceError: If temperature measurements fail or are out of range
            
        Note:
            Should include validity checks on temperature values.
            Must handle partial sensor failures gracefully.
        """
        pass


class ExperimentDeviceInterface(ABC):
    """High-level interface for experiment control.
    
    Provides experiment-focused operations that coordinate multiple device
    components. This is the primary interface used by experiment control logic.
    
    Responsible for:
    - Measurement coordination
    - Dilution operations
    - Status monitoring
    - Emergency handling
    
    Implementation must ensure:
    - Operation atomicity
    - Error recovery
    - Data consistency
    - Safe state management
    
    Typical usage:
        measurements = device.measure_vial(1)
        device.make_dilution(1, media_ml=5.0, drug_ml=0.5)
        status = device.vial_status
    """
    
    @abstractmethod
    def measure_vial(self, vial: int) -> VialMeasurements:
        """Get all measurements for a specific vial.
        
        Performs a complete measurement cycle:
        1. Temperature reading
        2. RPM measurement if available
        3. OD measurement
        4. Growth rate calculation if possible
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            VialMeasurements: Combined measurements from vial
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If critical measurements fail
            
        Note:
            Should complete all possible measurements even if some fail.
            Critical measurements (OD) failure causes error.
        """
        pass
    
    @abstractmethod
    def make_dilution(self, vial: int, media_volume: float, drug_volume: float) -> None:
        """Perform dilution operation on specific vial.
        
        Executes complete dilution sequence:
        1. Verify volumes and vial state
        2. Remove waste volume
        3. Add fresh media
        4. Add drug solution
        5. Verify operation completion
        
        Args:
            vial: Vial number (1-7)
            media_volume: Volume of fresh media to add in ml
            drug_volume: Volume of drug solution to add in ml
            
        Raises:
            ValueError: If vial number or volumes invalid
            DeviceError: If dilution operation fails
            
        Note:
            Operation must be atomic - should revert to safe state on error.
            Must verify all steps complete successfully.
        """
        pass

    @abstractmethod
    def emergency_stop(self) -> None:
        """Emergency stop all device operations.
        
        Immediately stops all device components and sets system to safe state:
        1. Stop all pumps
        2. Close all valves
        3. Stop all stirrers
        4. Turn off all lasers
        5. Set status LEDs to error state
        
        Should be called in response to:
        - Critical errors
        - Safety interlock triggers
        - User emergency stop
        - Power issues
        
        Note:
            Most critical safety method - must be extremely reliable.
            Should attempt all steps even if some fail.
            Must log all actions and failures.
        """
        pass

    @property
    @abstractmethod
    def vial_status(self) -> Dict[int, Dict[str, float]]:
        """Get current status of all vials.
        
        Provides snapshot of system state including:
        - OD readings
        - Temperatures
        - Stirrer speeds
        - Growth rates
        
        Returns:
            Dict[int, Dict[str, float]]: Status data
                Keys: vial numbers (1-7)
                Values: dict with measurement values
                    'od': Current optical density
                    'temperature': Current temperature
                    'rpm': Current stirrer speed if available
                    'growth_rate': Current growth rate if available
        
        Note:
            Should return best available data even if some readings fail.
            Must indicate missing/failed measurements appropriately.
        """
        pass


class DeviceEventListener(ABC):
    """Interface for listening to device events."""
    
    @abstractmethod
    def on_pump_status_change(self, pump_id: int, active: bool) -> None:
        """Called when a pump's status changes."""
        pass
        
    @abstractmethod
    def on_valve_status_change(self, valve_id: int, is_open: bool) -> None:
        """Called when a valve's status changes."""
        pass

--- core/src/replifactory_core/parameters.py ---
from dataclasses import dataclass
from enum import Enum
from typing import Optional

@dataclass
class VialMeasurements:
    """Container for measurements from a single vial.
    
    Contains all measurements that can be taken from a vial at a single point in time.
    Used to group measurements and handle missing/failed readings gracefully.
    
    Attributes:
        od: Optical density measurement
        temperature: Temperature in Celsius
        rpm: Stirrer speed in rotations per minute (None if not available)
        growth_rate: Calculated growth rate in 1/hour (None if not enough data)
        signal_mv: Raw photodiode signal in millivolts (None if not relevant)
        blank_mv: Calibration blank reading in millivolts (None if not set)
        
    Note:
        - Only od and temperature are required
        - Other fields may be None if measurement failed or isn't available
        - signal_mv and blank_mv are for OD measurement diagnostics
    """
    od: float
    temperature: float
    rpm: Optional[float] = None
    growth_rate: Optional[float] = None 
    signal_mv: Optional[float] = None
    blank_mv: Optional[float] = None

    def __post_init__(self):
        """Validate measurements after initialization."""
        if self.od < 0:
            raise ValueError("OD cannot be negative")
        if self.temperature < 0 or self.temperature > 50:
            raise ValueError("Temperature out of valid range (0-50°C)")
        if self.rpm is not None and self.rpm < 0:
            raise ValueError("RPM cannot be negative")
        if self.signal_mv is not None and self.signal_mv < 0:
            raise ValueError("Signal voltage cannot be negative")
        if self.blank_mv is not None and self.blank_mv < 0:
            raise ValueError("Blank voltage cannot be negative")

@dataclass
class PumpParameters:
    """Parameters defining pump operational characteristics.
    
    Attributes:
        max_volume_ml: Maximum volume in ml that can be pumped in one operation
        min_volume_ml: Minimum volume in ml that can be reliably pumped
        flow_rate_mlps: Flow rate in milliliters per second
    
    Note:
        These parameters are used for both real and simulated pumps to ensure
        consistent behavior across implementations.
    """
    max_volume_ml: float 
    min_volume_ml: float
    flow_rate_mlps: float  


@dataclass
class ODParameters:
    """Parameters for optical density measurements.
    
    These settings control the sensitivity and accuracy of OD readings.
    
    Attributes:
        gain: Amplification factor for photodiode signal (1, 2, 4, or 8)
            Higher gain for low OD samples, lower for high OD
        bitrate: ADC resolution in bits (12, 14, 16, or 18)
            Higher bitrate gives better precision but slower readings
        continuous_conversion: If True, ADC runs continuously
        samples_to_average: Number of samples to take and average
    """
    gain: int = 8
    bitrate: int = 16
    continuous_conversion: bool = False
    samples_to_average: int = 3


@dataclass
class LaserParameters:
    """Parameters for laser operation.
    
    Controls laser behavior during measurements.
    
    Attributes:
        warmup_time_ms: Time to wait after laser on before reading
        measurement_time_ms: Duration of measurement
        cooldown_time_ms: Time to wait between measurements
    """
    warmup_time_ms: int = 20
    measurement_time_ms: int = 100
    cooldown_time_ms: int = 50


@dataclass
class StirrerParameters:
    """Parameters for stirrer operation.
    
    Defines stirring behavior for different modes.
    
    Attributes:
        high_speed_duty_cycle: PWM duty cycle for normal operation (0-1)
        low_speed_duty_cycle: PWM duty cycle for measurement (0-1)
        acceleration_time_ms: Time to reach target speed
    """
    high_speed_duty_cycle: float = 0.8
    low_speed_duty_cycle: float = 0.3
    acceleration_time_ms: int = 100


@dataclass
class MeasurementParameters:
    """Combined parameters for all measurement operations.
    
    Collects all measurement-related parameters in one place.
    
    Attributes:
        od: Optical density measurement parameters
        laser: Laser operation parameters
        stirrer: Stirrer behavior parameters
        wait_for_steady_state: If True, verify readings are stable
        max_retries: Number of measurement retries on error
    """
    od: ODParameters = ODParameters()
    laser: LaserParameters = LaserParameters()
    stirrer: StirrerParameters = StirrerParameters()
    wait_for_steady_state: bool = True
    max_retries: int = 3

--- core/src/replifactory_core/protocols.py ---
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional, Dict, List
from datetime import datetime
import numpy as np

from .culture import Culture
from .parameters import VialMeasurements


@dataclass
class ProtocolConfig:
    """Base configuration for growth control protocols."""
    pass


@dataclass
class MorbidostatConfig(ProtocolConfig):
    """Configuration for morbidostat control protocol.
    
    Attributes:
        od_threshold: OD level that triggers dilution
        target_growth_rate: Desired growth rate to maintain
        growth_rate_tolerance: Acceptable deviation from target
        min_growth_rate: Growth rate below which rescue dilution occurs
        max_drug_concentration: Maximum allowed drug concentration
        drug_concentration_step: Relative increase in drug concentration
        dilution_factor: Factor by which to dilute culture
        measurement_window_mins: Time window for growth rate calculation
    """
    od_threshold: float = 0.3
    target_growth_rate: float = 0.15  # hr^-1
    growth_rate_tolerance: float = 0.05
    min_growth_rate: float = -0.1
    max_drug_concentration: float = 100.0
    drug_concentration_step: float = 1.5
    dilution_factor: float = 1.6
    measurement_window_mins: int = 30


class GrowthControlProtocol(ABC):
    """Base class for growth control protocols.
    
    Defines interface for implementing different control strategies.
    """
    
    @abstractmethod
    def update(self, culture: Culture) -> Optional[Dict]:
        """Update control protocol for a culture.
        
        Args:
            culture: Culture to update
            
        Returns:
            Optional[Dict]: Control actions taken, if any
        """
        pass
    
    @abstractmethod
    def get_status(self) -> Dict:
        """Get current protocol status."""
        pass


class MorbidostatProtocol(GrowthControlProtocol):
    """Morbidostat growth control protocol.
    
    Implements feedback control to maintain constant growth rate by
    adjusting drug concentration. Core logic:
    
    1. Dilute when OD exceeds threshold
    2. If growth rate too high: increase drug concentration
    3. If growth rate too low: decrease drug concentration
    4. If growth severely inhibited: perform rescue dilution
    
    Args:
        config: Protocol configuration parameters
    """
    
    def __init__(self, config: MorbidostatConfig = MorbidostatConfig()):
        self.config = config
        self._history: List[Dict] = []
        
    def update(self, culture: Culture) -> Optional[Dict]:
        """Update morbidostat control for a culture.
        
        Implements core morbidostat logic:
        1. Calculate current growth rate
        2. Determine if dilution needed
        3. Adjust drug concentration based on growth rate
        
        Args:
            culture: Culture to update
            
        Returns:
            Dict with control actions if any were taken
        """
        # Get current measurements
        measurements = culture.measure()
        growth_rate = culture.calculate_growth_rate(
            window_minutes=self.config.measurement_window_mins
        )
        
        # Initialize response
        response = {
            'timestamp': datetime.now(),
            'od': measurements.od,
            'growth_rate': growth_rate,
            'drug_concentration': culture.current_drug_concentration,
            'action': None
        }
        
        # Check if growth rate could be calculated
        if growth_rate is None:
            self._history.append(response)
            return response
            
        # Determine control action
        action = self._determine_control_action(measurements, growth_rate)
        
        # Execute control action
        if action:
            response['action'] = action
            self._execute_control_action(culture, action)
            
        self._history.append(response)
        return response
    
    def _determine_control_action(
        self, 
        measurements: VialMeasurements, 
        growth_rate: float
    ) -> Optional[str]:
        """Determine appropriate control action based on measurements.
        
        Args:
            measurements: Current culture measurements
            growth_rate: Calculated growth rate
            
        Returns:
            String indicating control action or None if no action needed
        """
        # Check for severely inhibited growth
        if growth_rate < self.config.min_growth_rate:
            return 'rescue_dilution'
            
        # Check if OD threshold exceeded
        if measurements.od < self.config.od_threshold:
            return None
            
        # Determine drug adjustment based on growth rate
        growth_error = growth_rate - self.config.target_growth_rate
        
        if abs(growth_error) <= self.config.growth_rate_tolerance:
            return 'maintain'
        elif growth_error > 0:
            return 'increase_drug'
        else:
            return 'decrease_drug'
    
    def _execute_control_action(self, culture: Culture, action: str) -> None:
        """Execute determined control action.
        
        Args:
            culture: Culture to control
            action: Control action to execute
        """
        current_conc = culture.current_drug_concentration
        
        if action == 'rescue_dilution':
            # Perform dilution with reduced drug concentration
            new_conc = max(0, current_conc / self.config.drug_concentration_step)
            culture.make_dilution(target_drug_concentration=new_conc)
            
        elif action == 'maintain':
            # Maintain current drug concentration
            culture.make_dilution()
            
        elif action == 'increase_drug':
            # Increase drug concentration
            new_conc = min(
                self.config.max_drug_concentration,
                current_conc * self.config.drug_concentration_step
            )
            culture.make_dilution(target_drug_concentration=new_conc)
            
        elif action == 'decrease_drug':
            # Decrease drug concentration
            new_conc = current_conc / self.config.drug_concentration_step
            culture.make_dilution(target_drug_concentration=new_conc)
    
    def get_status(self) -> Dict:
        """Get current protocol status.
        
        Returns:
            Dict containing:
            - Configuration parameters
            - Control history
            - Current state
        """
        return {
            'config': self.config.__dict__,
            'history': self._history,
            'latest': self._history[-1] if self._history else None
        }


class TurbidostatProtocol(GrowthControlProtocol):
    """Turbidostat growth control protocol.
    
    Maintains constant cell density by diluting when OD exceeds threshold.
    No drug concentration adjustment.
    """
    # TODO: Implement turbidostat logic
    pass


class ChemostatProtocol(GrowthControlProtocol):
    """Chemostat growth control protocol.
    
    Maintains constant dilution rate regardless of growth.
    """
    # TODO: Implement chemostat logic
    pass 

--- core/src/replifactory_core/types.py ---


--- core/tests/.gitkeep ---


--- docs/developer-guide/.gitkeep ---


--- docs/index.md ---


--- docs/user-guide/.gitkeep ---


--- hardware/pyproject.toml ---


--- hardware/tests/.gitkeep ---


--- mkdocs.yml ---


--- nx.json ---


--- pyproject.toml ---
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "replifactory"
version = "0.1.0"
dependencies = [
    "numpy",
    "flask",
    "flask-sqlalchemy",
    "flask-cors",
    "flask-migrate",
    "waitress"
]

[tool.hatch.build.targets.wheel]
packages = [
    "core/src/replifactory_core",
    "simulation/src/replifactory_simulation", 
    "server/src/replifactory_server"
]

--- server/pyproject.toml ---
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "replifactory-server"
version = "0.1.0"
description = "Server components for the Replifactory bacterial evolution system"
authors = [
    { name = "Replifactory Team" }
]
readme = "README.md"
requires-python = ">=3.10"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dependencies = [
    "flask>=2.0.0",
    "flask-cors>=4.0.0",
    "flask-migrate>=4.0.0",
    "flask-sqlalchemy>=3.0.0",
    "waitress>=2.0.0",
    "sqlalchemy>=2.0.0",
    "replifactory-core>=0.1.0",
    "replifactory-simulation>=0.1.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/replifactory_server"]

[project.urls]
"Homepage" = "https://github.com/yourusername/replifactory"
"Bug Tracker" = "https://github.com/yourusername/replifactory/issues"


--- server/requirements.txt ---
flask>=2.0.0
flask-cors>=3.0.0
flask-migrate>=3.0.0
flask-sqlalchemy>=2.5.0
waitress>=2.0.0
flask-socketio>=5.3.0
python-socketio>=5.7.0
eventlet>=0.33.0 

--- server/src/replifactory_server/.gitkeep ---


--- server/src/replifactory_server/create_experiment.py ---
import requests
import json
import logging

logging.basicConfig(level=logging.DEBUG)

def create_experiment():
    experiment_data = {
        "name": "Test Experiment",
        "parameters": {
            # Experiment duration settings
            "max_duration_hours": 24,
            "measurement_interval_mins": 1,
            
            # Culture configuration
            "culture_config": {
                "od_threshold": 0.3,
                "growth_rate_threshold": 0.15,
                "min_growth_rate": -0.1,
                "dilution_factor": 1.6,
                "max_drug_concentration": 100.0
            },
            
            # Device configuration
            "device_config": {
                "n_vials": 2  # Only include valid parameters
            }
        }
    }
    
    url = 'http://localhost:5000/experiments'
    print(f"Sending POST request to: {url}")
    print(f"Request data: {json.dumps(experiment_data, indent=2)}")
    
    try:
        response = requests.post(
            url,
            json=experiment_data,
            headers={'Content-Type': 'application/json'}
        )
        
        print(f"Response status code: {response.status_code}")
        print(f"Response headers: {dict(response.headers)}")
        print(f"Response text: {response.text}")
        
        if response.status_code == 201:
            print("Experiment created successfully!")
            print(json.dumps(response.json(), indent=2))
            
            # Start the experiment
            experiment_id = response.json()['id']
            start_url = f'http://localhost:5000/experiments/{experiment_id}/start'
            print(f"\nStarting experiment {experiment_id}...")
            start_response = requests.post(start_url)
            print(f"Start response: {start_response.text}")
        else:
            print(f"Error creating experiment: {response.text}")
            
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")

if __name__ == "__main__":
    create_experiment() 

--- server/src/replifactory_server/database.py ---
from flask_sqlalchemy import SQLAlchemy

# Create a single SQLAlchemy instance to be used across the application
db = SQLAlchemy() 

--- server/src/replifactory_server/database_models.py ---
from datetime import datetime
from sqlalchemy import JSON
import json
from replifactory_server.database import db

class ExperimentModel(db.Model):
    __tablename__ = 'experiments'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    status = db.Column(db.String(20), default='inactive')
    parameters = db.Column(db.Text, nullable=False)  # JSON string
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    def __init__(self, name, parameters):
        self.name = name
        self.status = 'inactive'
        self.parameters = json.dumps(parameters) if isinstance(parameters, dict) else parameters
        
    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'status': self.status,
            'parameters': json.loads(self.parameters) if isinstance(self.parameters, str) else self.parameters,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

class MeasurementData(db.Model):
    __tablename__ = 'measurements'
    id = db.Column(db.Integer, primary_key=True)
    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False)
    vial = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.now)
    od = db.Column(db.Float)
    temperature = db.Column(db.Float)
    drug_concentration = db.Column(db.Float)
    growth_rate = db.Column(db.Float)

class DilutionData(db.Model):
    __tablename__ = 'dilutions'
    id = db.Column(db.Integer, primary_key=True)
    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False)
    vial = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.now)
    media_volume = db.Column(db.Float)
    drug_volume = db.Column(db.Float)
    target_concentration = db.Column(db.Float)

--- server/src/replifactory_server/init.py ---
from flask import Flask
from flask_cors import CORS
from flask_migrate import Migrate
from flask_socketio import SocketIO
import logging
from pathlib import Path

from replifactory_server.routes import device_routes, experiment_routes, service_routes
from replifactory_server.database import db
from replifactory_server.database_models import MeasurementData
from replifactory_simulation.simulation_factory import SimulationFactory
from replifactory_simulation.growth_model import GrowthModelParameters
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.base_device import BaseDeviceConfig
from replifactory_core.experiment import ExperimentConfig
from replifactory_server.monitor import ExperimentMonitor
from replifactory_simulation.simulation_factory import create_simulated_device

logger = logging.getLogger(__name__)

def init_app(app, config=None):
    """Initialize the Flask application with all its components."""
    # Initialize SocketIO
    socketio = SocketIO(app, 
        cors_allowed_origins="*",
        logger=True,
        engineio_logger=True,
        async_mode='threading'
    )
    app.config['socketio'] = socketio
    
    # Ensure instance folder exists
    instance_path = Path(app.instance_path)
    instance_path.mkdir(parents=True, exist_ok=True)
    
    # Set database path
    db_path = instance_path / 'replifactory.db'
    
    # Load default configuration
    default_config = {
        'SQLALCHEMY_DATABASE_URI': f'sqlite:///{db_path}',
        'SQLALCHEMY_TRACK_MODIFICATIONS': False,
        'MODE': 'simulation',  # Default to simulation mode
        'DATABASE_PATH': db_path,
        'TIME_ACCELERATION': 100.0
    }
    
    # Apply default config
    app.config.from_mapping(default_config)
    
    # Override with provided config if any
    if config:
        app.config.update(config)
    
    logger.info(f"Database path: {db_path}")
    logger.info(f"Running in {app.config['MODE']} mode")
    
    # Initialize extensions
    CORS(app, resources={
        r"/*": {
            "origins": "*",
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
            "allow_headers": ["Content-Type", "Authorization"]
        }
    })
    db.init_app(app)
    Migrate(app, db)
    
    # Register blueprints
    app.register_blueprint(device_routes)
    app.register_blueprint(experiment_routes)
    app.register_blueprint(service_routes)
    
    return app

def init_device(app):
    """Initialize the device and simulation components."""
    with app.app_context():
        try:
            # Create database tables
            db.create_all()
            logger.info("Database tables created successfully")
            
            # Initialize device based on mode
            logger.info(f"Current mode: {app.config['MODE']}")
            if app.config['MODE'] == 'simulation':
                logger.info("Initializing simulation mode")
                # Create monitor for event handling
                monitor = ExperimentMonitor()
                app.monitor = monitor  # Store monitor in app context
                
                # Create device with monitor
                device_config = BaseDeviceConfig()
                app.device = create_simulated_device(config=device_config, monitor=monitor)
                logger.info("Device created successfully")
                
                # Create simulation runner
                app.simulation_runner = SimulationRunner(
                    device=app.device,
                    config=ExperimentConfig(),
                    time_acceleration=app.config.get('TIME_ACCELERATION', 100.0),
                    app=app,
                    db=db,
                    measurement_model=MeasurementData
                )
                logger.info(f"Simulation initialized with {app.config.get('TIME_ACCELERATION', 100.0)}x time acceleration")
                logger.info(f"Device initialized: {hasattr(app, 'device')}")
                logger.info(f"Simulation runner initialized: {hasattr(app, 'simulation_runner')}")
            else:
                logger.info("Initializing hardware mode")
                # Initialize hardware device here
                pass
                
        except Exception as e:
            logger.error(f"Error during initialization: {str(e)}")
            logger.error(f"Current app config: {app.config}")
            raise
            
    return app 

--- server/src/replifactory_server/init_db.py ---
from replifactory_server.server import create_app
from replifactory_server.models import db

def init_db():
    app = create_app()
    with app.app_context():
        db.create_all()
        print("Database initialized successfully")

if __name__ == '__main__':
    init_db() 

--- server/src/replifactory_server/models.py ---
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class ExperimentModel(db.Model):
    __tablename__ = 'experiments'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    status = db.Column(db.String(20), default='created')
    parameters = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.now)
    measurements = db.relationship('MeasurementData', backref='experiment', lazy=True)

class MeasurementData(db.Model):
    __tablename__ = 'measurements'
    id = db.Column(db.Integer, primary_key=True)
    experiment_id = db.Column(db.Integer, db.ForeignKey('experiments.id'), nullable=False)
    vial = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.now)
    od = db.Column(db.Float)
    temperature = db.Column(db.Float)
    drug_concentration = db.Column(db.Float)
    growth_rate = db.Column(db.Float) 

--- server/src/replifactory_server/monitor.py ---
from datetime import datetime, timedelta
import logging
from typing import Dict, Optional
from flask import current_app
from replifactory_core.interfaces import DeviceEventListener
from replifactory_server.database_models import ExperimentModel

logger = logging.getLogger(__name__)

class ExperimentMonitor(DeviceEventListener):
    """Monitor for experiment events and device status updates."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.last_check = datetime.now() - timedelta(minutes=5)
        self.active_experiment: Optional[ExperimentModel] = None
        self.vial_data: Dict[int, Dict] = {}
        
    def get_active_experiment(self):
        """Get the currently running experiment."""
        experiment = ExperimentModel.query.filter_by(status='running')\
            .order_by(ExperimentModel.created_at.desc())\
            .first()
        if experiment:
            self.active_experiment = experiment
            return True
        return False
            
    def print_status(self, measurements):
        """Print formatted status update and emit WebSocket events."""
        self.logger.info("="*50)
        self.logger.info(f"Status Update at {datetime.now().strftime('%H:%M:%S')}")
        self.logger.info(f"Experiment: {self.active_experiment.name}")
        self.logger.info("-"*50)
        
        # Group measurements by vial
        vial_updates = {}
        for m in measurements:
            if m.vial not in vial_updates:
                vial_updates[m.vial] = []
            vial_updates[m.vial].append(m)
        
        # Process and emit measurements for each vial
        for vial in sorted(vial_updates.keys()):
            latest = vial_updates[vial][-1]  # Get most recent measurement
            vial_data = {
                'vial': vial,
                'od': float(latest.od),  # Ensure numeric type
                'temperature': float(latest.temperature),
                'drug_concentration': float(latest.drug_concentration) if latest.drug_concentration is not None else 0.0,
                'growth_rate': float(latest.growth_rate) if latest.growth_rate is not None else 0.0,
                'timestamp': latest.timestamp.isoformat()
            }
            
            # Emit vial update via WebSocket
            socketio = current_app.config['socketio']
            self.logger.debug(f"Emitting vial update: {vial_data}")
            socketio.emit('vial_update', vial_data)
            
            self.logger.info(f"\nVial {vial}:")
            self.logger.info(f"  OD: {latest.od:.3f}")
            self.logger.info(f"  Temperature: {latest.temperature:.1f}°C")
            if latest.drug_concentration is not None:
                self.logger.info(f"  Drug Concentration: {latest.drug_concentration:.2f}")
            if latest.growth_rate is not None:
                self.logger.info(f"  Growth Rate: {latest.growth_rate:.3f}/hr")
            
            # Calculate changes since last measurement
            if len(vial_updates[vial]) > 1:
                previous = vial_updates[vial][-2]
                od_change = latest.od - previous.od
                time_diff = (latest.timestamp - previous.timestamp).total_seconds() / 3600
                if time_diff > 0:
                    self.logger.info(f"  OD Change: {od_change:.3f} ({od_change/time_diff:.3f}/hr)")
        
        self.logger.info("="*50)
        
    def on_pump_status_change(self, pump_id: int, active: bool) -> None:
        """Emit pump status update via WebSocket."""
        socketio = current_app.config['socketio']
        socketio.emit('pump_status', {
            'pump': pump_id,
            'active': active,
            'timestamp': datetime.now().isoformat()
        })
        
    def on_valve_status_change(self, valve_id: int, is_open: bool) -> None:
        """Emit valve status update via WebSocket."""
        socketio = current_app.config['socketio']
        socketio.emit('valve_status', {
            'valve': valve_id,
            'open': is_open,
            'timestamp': datetime.now().isoformat()
        })

def main():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    monitor = ExperimentMonitor()
    monitor.run()

if __name__ == '__main__':
    main() 

--- server/src/replifactory_server/routes.py ---
from flask import Blueprint, request, jsonify, current_app
from datetime import datetime
import json
import logging

from replifactory_core.experiment import Experiment, ExperimentConfig
from replifactory_core.base_device import BaseDeviceConfig
from replifactory_server.database import db
from replifactory_server.database_models import ExperimentModel, MeasurementData
from replifactory_core.culture import CultureConfig

# Create blueprints
device_routes = Blueprint('device_routes', __name__)
experiment_routes = Blueprint('experiment_routes', __name__)
service_routes = Blueprint('service_routes', __name__)

logger = logging.getLogger(__name__)

# Add service routes
@service_routes.route('/service/status', methods=['GET'])
def get_service_status():
    return jsonify({
        'status': 'running',
        'timestamp': datetime.now().isoformat(),
        'mode': current_app.config.get('MODE', 'unknown')
    })


@device_routes.route('/device/status', methods=['GET'])
def get_device_status():
    if not hasattr(current_app, 'device'):
        return jsonify({'error': 'Device not initialized'}), 500
    return jsonify({'status': 'ready'})

@device_routes.route('/device/measurements', methods=['GET'])
def get_device_measurements():
    if not hasattr(current_app, 'device'):
        return jsonify({'error': 'Device not initialized'}), 500
        
    vial = request.args.get('vial', type=int)
    if not vial or not 1 <= vial <= current_app.device.config.n_vials:
        return jsonify({'error': 'Invalid vial number'}), 400
        
    try:
        measurements = current_app.device.measure_vial(vial)
        return jsonify({
            'od': measurements.od,
            'temperature': measurements.temperature,
            'rpm': measurements.rpm
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@device_routes.route('/device/pump', methods=['POST'])
def activate_pump():
    try:
        data = request.get_json()
        pump_id = data.get('pump')
        volume = data.get('volume')

        if not pump_id or not volume:
            return jsonify({'error': 'Missing pump id or volume'}), 400

        if not hasattr(current_app, 'device'):
            return jsonify({'error': 'Device not initialized'}), 500

        # Activate the pump
        current_app.device.activate_pump(pump_id, volume)
        
        return jsonify({'message': f'Pump {pump_id} activated with volume {volume}mL'})

    except Exception as e:
        return jsonify({'error': str(e)}), 500

@device_routes.route('/device/valve', methods=['POST'])
def set_valve_state():
    try:
        data = request.get_json()
        valve_id = data.get('valve')
        state = data.get('state')

        if valve_id is None or state is None:
            return jsonify({'error': 'Missing valve id or state'}), 400

        if not hasattr(current_app, 'device'):
            return jsonify({'error': 'Device not initialized'}), 500

        # Set the valve state
        current_app.device.set_valve_state(valve_id, state)
        
        return jsonify({'message': f'Valve {valve_id} set to {"open" if state else "closed"}'})

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Experiment routes
experiment_routes = Blueprint('experiment_routes', __name__)

@experiment_routes.route('/experiments', methods=['GET'])
def get_experiments():
    experiments = ExperimentModel.query.all()
    return jsonify([exp.to_dict() for exp in experiments])

@experiment_routes.route('/experiments', methods=['POST'])
def create_experiment():
    try:
        data = request.get_json()
        logger.debug(f"Received experiment data: {data}")
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
            
        # Create new experiment record
        experiment = ExperimentModel(
            name=data.get('name', f'Experiment_{datetime.now().strftime("%Y%m%d_%H%M%S")}'),
            parameters=data.get('parameters', {})
        )
        experiment.status = 'created'  # Set status after creation
        
        # Save to database
        db.session.add(experiment)
        db.session.commit()
        
        logger.info(f"Created experiment: {experiment.id}")
        
        return jsonify({
            'message': 'Experiment created successfully',
            'id': experiment.id,
            'name': experiment.name,
            'status': experiment.status
        }), 201
        
    except Exception as e:
        logger.error(f"Error creating experiment: {str(e)}")
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@experiment_routes.route('/experiments/<int:id>', methods=['GET'])
def get_experiment(id):
    experiment = ExperimentModel.query.get_or_404(id)
    return jsonify(experiment.to_dict())

@experiment_routes.route('/experiments/current/status', methods=['PUT'])
def update_experiment_status():
    status = request.json['status']
    
    if not hasattr(current_app, 'experiment'):
        return jsonify({'error': 'No experiment selected'}), 404
        
    if status == 'running':
        current_app.experiment.start()
    elif status == 'stopped':
        current_app.experiment.stop()
    elif status == 'paused':
        current_app.experiment.pause()
        
    return jsonify({'message': f'Experiment {status}'})

@experiment_routes.route('/plot/<int:vial>', methods=['GET'])
def get_culture_plot(vial):
    if not hasattr(current_app, 'experiment'):
        return jsonify({'error': 'No experiment selected'}), 404
        
    measurements = MeasurementData.query.filter_by(
        experiment_id=current_app.experiment.model.id,
        vial=vial
    ).order_by(MeasurementData.timestamp).all()
    
    # Create plot data
    data = {
        'times': [m.timestamp.isoformat() for m in measurements],
        'ods': [m.od for m in measurements],
        'drug_concentrations': [m.drug_concentration for m in measurements],
        'growth_rates': [m.growth_rate for m in measurements]
    }
    
    return jsonify(data)

@experiment_routes.route('/experiments/<int:id>/start', methods=['POST'])
def start_experiment(id):
    try:
        exp_model = ExperimentModel.query.get_or_404(id)
        
        # Get parameters from database
        parameters = json.loads(exp_model.parameters) if isinstance(exp_model.parameters, str) else exp_model.parameters
        
        # Create culture config from parameters
        culture_config = CultureConfig(
            od_threshold=parameters['culture_config'].get('od_threshold', 0.3),
            growth_rate_threshold=parameters['culture_config'].get('growth_rate_threshold', 0.15),
            min_growth_rate=parameters['culture_config'].get('min_growth_rate', -0.1),
            dilution_factor=parameters['culture_config'].get('dilution_factor', 1.6),
            max_drug_concentration=parameters['culture_config'].get('max_drug_concentration', 100.0)
        )
        
        # Create experiment config
        config = ExperimentConfig(
            max_duration_hours=parameters.get('max_duration_hours', 24),
            measurement_interval_mins=parameters.get('measurement_interval_mins', 1),
            culture_config=culture_config,
            device_config=BaseDeviceConfig(**parameters.get('device_config', {}))
        )
        
        # Initialize experiment
        if not hasattr(current_app, 'device'):
            current_app.logger.error("Device not initialized")
            return jsonify({'error': 'Device not initialized'}), 500
            
        # Create experiment
        current_app.experiment = Experiment(
            device=current_app.device,
            config=config,
            protocol=current_app.simulation_runner.protocol if hasattr(current_app, 'simulation_runner') else None
        )
        current_app.experiment.model = exp_model  # Set the experiment model
        
        # Start the experiment
        if hasattr(current_app, 'simulation_runner'):
            current_app.logger.info("Starting experiment in simulation mode")
            current_app.simulation_runner.experiment = current_app.experiment
            current_app.simulation_runner.experiment.model = exp_model  # Set the model on the simulation runner's experiment
            current_app.simulation_runner.start()
        else:
            current_app.logger.info("Starting experiment in hardware mode")
            current_app.experiment.start()
        
        # Update experiment status in database
        exp_model.status = 'running'
        db.session.commit()
        
        return jsonify({
            'message': 'Experiment started successfully',
            'experiment': {
                'id': exp_model.id,
                'name': exp_model.name,
                'status': exp_model.status
            }
        })
        
    except Exception as e:
        current_app.logger.error(f"Error starting experiment: {str(e)}")
        return jsonify({'error': str(e)}), 500

@experiment_routes.route('/experiments/active', methods=['GET'])
def get_active_experiment():
    """Get currently running experiment."""
    try:
        current_app.logger.info("Fetching active experiment...")
        
        # Get the most recent running experiment
        experiment = ExperimentModel.query\
            .filter_by(status='running')\
            .order_by(ExperimentModel.created_at.desc())\
            .first()
            
        response_data = {'experiment': experiment.to_dict() if experiment else None}
        response = current_app.make_response(response_data)
        response.headers.add('Access-Control-Allow-Origin', '*')
        
        if experiment:
            current_app.logger.info(f"Found active experiment: ID={experiment.id}, Name={experiment.name}")
        else:
            current_app.logger.info("No active experiments found")
            
        return response
            
    except Exception as e:
        current_app.logger.error(f"Error getting active experiment: {str(e)}", exc_info=True)
        return jsonify({'error': str(e)}), 500

# Add to_dict method to ExperimentModel
def to_dict(self):
    return {
        'id': self.id,
        'name': self.name,
        'status': self.status,
        'parameters': json.loads(self.parameters) if isinstance(self.parameters, str) else self.parameters,
        'created_at': self.created_at.isoformat() if self.created_at else None
    }

ExperimentModel.to_dict = to_dict

--- server/src/replifactory_server/server.py ---
from flask import Flask, request
import logging
import sys

from replifactory_server.init import init_app, init_device

logger = logging.getLogger(__name__)

def create_app(config=None):
    # Set up logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    # Create Flask app
    app = Flask(__name__)
    
    # Add CORS preflight handler
    @app.before_request
    def handle_preflight():
        if request.method == "OPTIONS":
            response = app.make_default_options_response()
            response.headers.add('Access-Control-Allow-Origin', '*')
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
            response.headers.add('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
            return response
    
    # Initialize app components
    app = init_app(app, config)
    
    # Initialize device
    app = init_device(app)
    
    return app

def run_server(host='0.0.0.0', port=5000, mode='simulation', config=None):
    if config is None:
        config = {}
    config['MODE'] = mode
    
    app = create_app(config)
    logger.info(f"Starting server in {mode} mode on {host}:{port}")
    logger.info(f"Time acceleration factor: {app.config.get('TIME_ACCELERATION', 100.0)}x")
    
    socketio = app.config['socketio']
    socketio.run(app, host=host, port=port, debug=True, allow_unsafe_werkzeug=True)

def main():
    development = len(sys.argv) > 1 and sys.argv[1] == 'develop'
    
    config = {
        'MODE': 'simulation',  # Always use simulation mode
        'TIME_ACCELERATION': 100.0
    }
    
    if development:
        print("Running in development mode")
        app = create_app(config)
        app.run(debug=True, host="0.0.0.0", port=5000)
    else:
        print("Running in production mode")
        run_server(host="0.0.0.0", port=5000, mode='simulation', config=config)

if __name__ == '__main__':
    main()

--- server/src/replifactory_server/start_experiment.py ---
import requests
import json
import logging

logging.basicConfig(level=logging.DEBUG)

def start_experiment(experiment_id):
    url = f'http://localhost:5000/experiments/{experiment_id}/start'
    print(f"Starting experiment {experiment_id}")
    
    try:
        response = requests.post(url)
        print(f"Response status code: {response.status_code}")
        print(f"Response: {response.text}")
        
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")

if __name__ == "__main__":
    # Get the most recent experiment
    response = requests.get('http://localhost:5000/experiments')
    if response.status_code == 200:
        experiments = response.json()
        if experiments:
            latest_experiment = experiments[-1]
            start_experiment(latest_experiment['id'])
        else:
            print("No experiments found")
    else:
        print(f"Failed to get experiments: {response.text}") 

--- server/src/replifactory_server/start_server.py ---
import argparse
import logging
from replifactory_server.server import run_server

def main():
    parser = argparse.ArgumentParser(description='Start the Replifactory server')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5000, help='Port to listen on')
    parser.add_argument('--mode', default='simulation', choices=['simulation', 'hardware'], 
                       help='Server mode (simulation or hardware)')
    parser.add_argument('--debug', action='store_true', help='Enable debug logging')
    parser.add_argument('--time-acceleration', type=float, default=100.0,
                       help='Time acceleration factor for simulation mode (default: 100.0)')
    
    args = parser.parse_args()
    
    # Set up logging
    logging.basicConfig(
        level=logging.DEBUG if args.debug else logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Run server
    config = {
        'MODE': args.mode,
        'TIME_ACCELERATION': args.time_acceleration
    }
    run_server(host=args.host, port=args.port, mode=args.mode, config=config)

if __name__ == '__main__':
    main() 

--- server/tests/.gitkeep ---


--- simulation/examples/quick_start.py ---
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.experiment import ExperimentConfig
from replifactory_simulation.growth_model import GrowthModelParameters
import time
import logging
from datetime import datetime

def main():
    # Set up logging
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)
    
    # Create configuration
    exp_config = ExperimentConfig(
        measurement_interval_mins=10,
        max_duration_hours=24,
        max_generations=None  # Allow experiment to run full duration
    )
    
    # Configure realistic growth parameters
    model_params = GrowthModelParameters(
        doubling_time_mins=30,        # Fast growing bacteria
        initial_od=0.1,               # Starting OD
        carrying_capacity=1.0,        # Maximum OD
        ic50_initial=10.0,            # Initial drug resistance
        adaptation_rate_max=0.1       # Allow for evolution
    )
    
    print(f"Starting simulation at {datetime.now().strftime('%H:%M:%S')}")
    print(f"Running {exp_config.max_duration_hours}-hour experiment at 10000x speed")
    print("Press Ctrl+C to stop early\n")
    
    # Create simulation
    runner = SimulationRunner(
        config=exp_config,
        model_params=model_params,
        time_acceleration=10000.0
    )
    
    try:
        # Start simulation
        runner.start()
        
        # Monitor progress
        start_time = time.time()
        last_print = start_time
        
        while runner.experiment._status == "running":
            current_time = time.time()
            
            # Print status update every 5 seconds
            if current_time - last_print >= 5.0:
                status = runner.experiment.status
                sim_hours = status['duration_hours']
                
                print(f"\nSimulation Time: {sim_hours:.1f}h / {exp_config.max_duration_hours}h")
                print("Culture Status:")
                
                for vial, data in status['cultures'].items():
                    print(f"  Vial {vial}:")
                    print(f"    OD: {data['od']:.3f}")
                    if 'drug_concentration' in data:
                        print(f"    Drug: {data['drug_concentration']:.1f}")
                    if 'growth_rate' in data:
                        print(f"    Growth Rate: {data['growth_rate']:.3f}/hr")
                        
                last_print = current_time
            
            # Don't burn CPU
            time.sleep(0.1)
            
    except KeyboardInterrupt:
        print("\nStopping simulation early...")
    finally:
        runner.stop()
        
        # Show results
        print("\nGenerating plots...")
        runner.data_logger.plot_growth_curves()
        
        # Load and show final statistics
        df = runner.data_logger.load_measurements()
        if not df.empty:
            print("\nExperiment Summary:")
            print(f"Duration: {df['timestamp'].max() - df['timestamp'].min()}")
            print(f"Total measurements: {len(df)}")
            print("\nFinal ODs:")
            final_ods = df.groupby('vial').last()['od']
            print(final_ods)
        else:
            logger.warning("No measurements recorded!")

if __name__ == "__main__":
    main()

--- simulation/examples/run_simulation.py ---
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.experiment import ExperimentConfig
from replifactory_simulation.growth_model import GrowthModelParameters
import time
import logging

def main():
    # Set up logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Create configuration
    exp_config = ExperimentConfig(
        measurement_interval_mins=10,
        max_duration_hours=24
    )
    
    model_params = GrowthModelParameters(
        doubling_time_mins=30,
        initial_od=0.1,
        carrying_capacity=1.0,
        ic50_initial=10.0
    )
    
    # Create and start simulation
    runner = SimulationRunner(
        config=exp_config,
        model_params=model_params,
        time_acceleration=100.0  # 100x speed
    )
    
    try:
        runner.start()
        
        # Monitor simulation
        while runner.experiment._status == "running":
            status = runner.experiment.status
            logging.info(f"Time: {status['duration_hours']:.1f}h")
            
            # Print culture status every minute
            for vial, data in status['cultures'].items():
                logging.info(
                    f"Vial {vial}: OD={data['od']:.3f}, "
                    f"Drug={data.get('drug_concentration', 0.0):.1f}"
                )
            
            time.sleep(60)  # Update display every minute
            
    except KeyboardInterrupt:
        logging.info("Stopping simulation...")
    finally:
        runner.stop()
        
        # Generate final plots and summary
        runner.data_logger.plot_growth_curves()
        
        df = runner.data_logger.load_measurements()
        if not df.empty:
            logging.info("\nExperiment Summary:")
            duration = df['timestamp'].max() - df['timestamp'].min()
            logging.info(f"Duration: {duration}")
            logging.info(f"Total measurements: {len(df)}")
            logging.info("\nFinal ODs:")
            final_ods = df.groupby('vial').last()['od']
            logging.info(final_ods)
        else:
            logging.warning("No measurements recorded!")

if __name__ == "__main__":
    main()

--- simulation/pyproject.toml ---
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "replifactory-simulation"
version = "0.1.0"
description = "Simulation components for the Replifactory bacterial evolution system"
authors = [
    { name = "Replifactory Team" }
]
readme = "README.md"
requires-python = ">=3.10"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dependencies = [
    "numpy>=1.21.0",
    "pandas>=2.0.0",
    "replifactory-core>=0.1.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/replifactory_simulation"]

[project.urls]
"Homepage" = "https://github.com/yourusername/replifactory"
"Bug Tracker" = "https://github.com/yourusername/replifactory/issues"


--- simulation/src/replifactory_simulation/.gitkeep ---


--- simulation/src/replifactory_simulation/__init__.py ---


--- simulation/src/replifactory_simulation/devices.py ---
from dataclasses import dataclass
import time
from typing import Dict, Optional, Tuple
import threading
import numpy as np
import logging

from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface, StirrerSpeed,
    DeviceError, DeviceEventListener
)
from replifactory_core.parameters import ODParameters

from .growth_model import GrowthModel, GrowthModelParameters

logger = logging.getLogger(__name__)

@dataclass
class SimulatedPump(PumpInterface):    
    pump_number: int
    flow_rate_mlps: float = 1.0
    event_listener: Optional[DeviceEventListener] = None
    
    def __post_init__(self):
        self._is_pumping = False
        self._volume_pumped = 0.0
        self._lock = threading.Lock()  # Lock for thread safety
    
    def pump(self, volume_ml: float) -> None:
        logger.debug(f"Pump {self.pump_number} attempting to pump {volume_ml}ml")
        if not self._lock.acquire(blocking=False):  # Try to acquire lock
            raise DeviceError("Pump already in use")
        
        try:
            self._is_pumping = True
            if self.event_listener:
                self.event_listener.on_pump_status_change(self.pump_number, True)
            
            duration = abs(volume_ml) / self.flow_rate_mlps
            logger.debug(f"Pump {self.pump_number} pumping for {duration:.2f}s")
            time.sleep(duration)  # Simulate pumping time
            self._volume_pumped += volume_ml
            logger.debug(f"Pump {self.pump_number} finished pumping")
        finally:
            self._is_pumping = False
            if self.event_listener:
                self.event_listener.on_pump_status_change(self.pump_number, False)
            self._lock.release()
    
    def stop(self) -> None:
        logger.debug(f"Stopping pump {self.pump_number}")
        self._is_pumping = False
    
    @property
    def is_pumping(self) -> bool:
        return self._is_pumping
    
    @property
    def pumped_volume(self) -> float:
        return self._volume_pumped

    def activate_pump(self, pump_id: int, volume_ul: float):
        """Activate a pump to dispense the specified volume."""
        if not 1 <= pump_id <= self.pump_number:
            raise ValueError(f"Invalid pump number: {pump_id}")
            
        # Emit pump active status
        self.monitor.emit_pump_status(pump_id, True)
        
        # Simulate pumping time
        time.sleep(volume_ul * 0.001)  # 1ms per µL
        
        # Emit pump inactive status
        self.monitor.emit_pump_status(pump_id, False)


class SimulatedValves(ValveInterface):
    def __init__(self, event_listener: Optional[DeviceEventListener] = None):
        self._states = {i: False for i in range(1, 8)}  # False = closed
        self.event_listener = event_listener
        logger.debug("Initialized valve states")
    
    def open(self, valve_number: int) -> None:
        logger.debug(f"Opening valve {valve_number}")
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        self._states[valve_number] = True
        if self.event_listener:
            self.event_listener.on_valve_status_change(valve_number, True)
        time.sleep(0.1)  # Simulate valve movement
    
    def close(self, valve_number: int) -> None:
        logger.debug(f"Closing valve {valve_number}")
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        self._states[valve_number] = False
        if self.event_listener:
            self.event_listener.on_valve_status_change(valve_number, False)
        time.sleep(0.1)  # Simulate valve movement
    
    def is_open(self, valve_number: int) -> bool:
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        return self._states[valve_number]
    
    def close_all(self) -> None:
        logger.debug("Closing all valves")
        for v in range(1, 8):
            self._states[v] = False


class SimulatedStirrer(StirrerInterface):
    def __init__(self):
        self._speeds = {i: StirrerSpeed.STOPPED for i in range(1, 8)}
        self._rpm_map = {
            StirrerSpeed.STOPPED: 0.0,
            StirrerSpeed.LOW: 400.0,
            StirrerSpeed.HIGH: 1200.0
        }
        logger.debug("Initialized stirrer speeds")
    
    def set_speed(self, vial: int, speed: StirrerSpeed) -> None:
        logger.debug(f"Setting vial {vial} stirrer to {speed}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
        self._speeds[vial] = speed
        time.sleep(0.2)  # Simulate speed change
    
    def measure_rpm(self, vial: int) -> float:
        logger.debug(f"Measuring RPM for vial {vial}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
        base_rpm = self._rpm_map[self._speeds[vial]]
        # Add some noise
        rpm = base_rpm * (1 + 0.05 * (2 * np.random.random() - 1))
        logger.debug(f"Vial {vial} RPM: {rpm:.1f}")
        return rpm
    
    def stop_all(self) -> None:
        logger.debug("Stopping all stirrers")
        for v in range(1, 8):
            self._speeds[v] = StirrerSpeed.STOPPED


class SimulatedODSensor(ODSensorInterface):
    """Simulates bacterial growth and OD measurements."""
    
    def __init__(self, model_params: Optional[GrowthModelParameters] = None):
        # Initialize growth models for each vial
        self._growth_models = {
            i: GrowthModel(parameters=model_params)
            for i in range(1, 8)
        }
        
        # Blank values for each vial
        self.blank_values = {i: 1000.0 for i in range(1, 8)}  # mV
        logger.debug("Initialized OD sensor with growth models")
        
    def measure_blank(self, vial: int) -> float:
        """Measure blank (empty vial) signal."""
        logger.debug(f"Measuring blank for vial {vial}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Add some noise to the blank measurement
        blank = self.blank_values[vial] * (1 + 0.005 * np.random.randn())
        time.sleep(0.1)  # Simulate measurement time
        logger.debug(f"Vial {vial} blank: {blank:.1f}mV")
        return blank
        
    def measure_od(self, vial: int, parameters: Optional[ODParameters] = None) -> Tuple[float, float]:
        logger.debug(f"Measuring OD for vial {vial}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Get current OD from growth model
        model = self._growth_models[vial]
        
        # Add measurement noise
        measured_od = model.od * (1 + 0.02 * np.random.randn())
        signal = 1000 * np.exp(-measured_od) * (1 + 0.01 * np.random.randn())
        
        time.sleep(0.1)  # Simulate measurement time
        logger.debug(f"Vial {vial} OD: {measured_od:.3f}, Signal: {signal:.1f}mV")
        return measured_od, signal
        
    def update_drug_concentration(self, vial: int, concentration: float):
        """Update drug concentration after dilution."""
        logger.debug(f"Updating vial {vial} drug concentration to {concentration}")
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        model = self._growth_models[vial]
        model.drug_concentration = concentration


class SimulatedThermometer(ThermometerInterface):
    def __init__(self):
        self._temp_setpoint = 37.0
        logger.debug("Initialized thermometer")
        
    def measure_temperature(self) -> Dict[str, float]:
        logger.debug("Measuring temperatures")
        # Add noise to temperature
        vial_temp = self._temp_setpoint + 0.5 * (2 * np.random.random() - 1)
        board_temp = 35.0 + 0.2 * (2 * np.random.random() - 1)
        
        time.sleep(0.1)  # Simulate measurement
        logger.debug(f"Temperatures - Vials: {vial_temp:.1f}°C, Board: {board_temp:.1f}°C")
        return {
            'vials': vial_temp,
            'board': board_temp
        }



--- simulation/src/replifactory_simulation/growth_model.py ---
from dataclasses import dataclass
import numpy as np
from typing import Optional


@dataclass
class GrowthModelParameters:
    """Parameters controlling bacterial growth simulation.
    
    Attributes:
        initial_od: Starting optical density
        doubling_time_mins: Time for population to double without drug
        carrying_capacity: Maximum OD the culture can reach
        mu_min: Minimum growth rate (can be negative for death)
        ic50_initial: Initial drug concentration causing 50% growth inhibition
        ic10_ic50_ratio: Ratio of IC10 to IC50 (controls dose response curve)
        adaptation_rate_max: Maximum rate of drug adaptation
        adaptation_rate_ic10_ic50_ratio: Controls adaptation vs. drug concentration
    """
    initial_od: float = 0.05
    doubling_time_mins: float = 2.0
    carrying_capacity: float = 0.9
    mu_min: float = -0.1
    ic50_initial: float = 5.0
    ic10_ic50_ratio: float = 0.5
    adaptation_rate_max: float = 0.08
    adaptation_rate_ic10_ic50_ratio: float = 0.8


class GrowthModel:
    """Simulates bacterial growth with drug adaptation.
    
    Implements core growth model including:
    - Basic bacterial growth
    - Drug response
    - Evolution of drug resistance
    - Population carrying capacity
    
    The model tracks:
    - Current population (OD)
    - Drug concentration
    - Drug resistance (IC50)
    - Growth rate
    """
    
    def __init__(self, parameters: Optional[GrowthModelParameters] = None):
        """Initialize growth model.
        
        Args:
            parameters: Growth model parameters. Uses defaults if None.
        """
        self.params = parameters or GrowthModelParameters()
        
        # Calculate base growth rate from doubling time
        self.mu_max = np.log(2) / (self.params.doubling_time_mins / 60)
        
        # Initialize state
        self.od = self.params.initial_od
        self.drug_concentration = 0.0
        self.ic50 = self.params.ic50_initial
        self._growth_rate = None
        
    def growth_rate(self, drug_conc: float, od: float) -> float:
        """Calculate growth rate under given conditions.
        
        Combines effects of:
        - Base growth rate
        - Drug inhibition
        - Carrying capacity
        
        Args:
            drug_conc: Current drug concentration
            od: Current optical density
            
        Returns:
            Growth rate in 1/hour
        """
        # Calculate drug effect using 4-parameter logistic
        ic10 = self.ic50 * self.params.ic10_ic50_ratio
        k = np.log(9) / (self.ic50 - ic10)
        drug_effect = self.params.mu_min + (
            self.mu_max / (1 + np.exp(-k * (self.ic50 - drug_conc)))
        )
        
        # Apply carrying capacity limitation
        capacity_effect = (1 - od / self.params.carrying_capacity)
        
        return drug_effect * capacity_effect
    
    def adaptation_rate(self, drug_conc: float) -> float:
        """Calculate rate of drug resistance adaptation.
        
        Models evolution of drug resistance using modified Gaussian curve.
        
        Args:
            drug_conc: Current drug concentration
            
        Returns:
            Adaptation rate in 1/hour
        """
        ic10 = self.ic50 * self.params.ic10_ic50_ratio
        k_adapt = -np.log(self.params.adaptation_rate_ic10_ic50_ratio) / ((ic10 - self.ic50) ** 2)
        return self.params.adaptation_rate_max * np.exp(-k_adapt * ((drug_conc - self.ic50) ** 2))
    
    def update(self, timestep_mins: float, new_drug_conc: Optional[float] = None):
        """Update model state for one timestep.
        
        Args:
            timestep_mins: Time step in minutes
            new_drug_conc: New drug concentration if changed, else uses current
            
        Updates internal state:
        - OD based on growth
        - IC50 based on adaptation
        - Stores current growth rate
        """
        if new_drug_conc is not None:
            self.drug_concentration = new_drug_conc
            
        # Calculate current growth rate
        self._growth_rate = self.growth_rate(self.drug_concentration, self.od)
        
        # Update population
        hours = timestep_mins / 60
        self.od *= np.exp(self._growth_rate * hours)
        
        # Update drug resistance
        adapt_rate = self.adaptation_rate(self.drug_concentration)
        self.ic50 *= np.exp(adapt_rate * hours)
    
    def dilute(self, dilution_factor: float, new_drug_conc: Optional[float] = None):
        """Perform dilution operation.
        
        Args:
            dilution_factor: Factor by which culture is diluted
            new_drug_conc: New drug concentration after dilution
        """
        self.od /= dilution_factor
        if new_drug_conc is not None:
            self.drug_concentration = new_drug_conc
            
    @property
    def growth_rate_current(self) -> float:
        """Get most recently calculated growth rate."""
        return self._growth_rate if self._growth_rate is not None else 0.0

--- simulation/src/replifactory_simulation/logging.py ---
from dataclasses import dataclass, asdict
from datetime import datetime
import json
import os
from pathlib import Path
from typing import Dict, List, Optional, Union
import pandas as pd
import numpy as np

@dataclass
class MeasurementLog:
    """Single measurement data point.
    
    Attributes:
        timestamp: Time of measurement
        vial: Vial number
        od: Optical density
        temperature: Temperature in Celsius
        drug_concentration: Current drug concentration
        growth_rate: Calculated growth rate if available
        action: Control action taken if any
    """
    timestamp: datetime
    vial: int
    od: float
    temperature: float
    drug_concentration: float
    growth_rate: Optional[float] = None
    action: Optional[str] = None

@dataclass
class ExperimentLog:
    """Complete experiment log.
    
    Attributes:
        experiment_id: Unique experiment identifier
        start_time: Experiment start time
        config: Experiment configuration
        measurements: List of all measurements
        events: List of significant events
    """
    experiment_id: str
    start_time: datetime
    config: Dict
    measurements: List[MeasurementLog] = None
    events: List[Dict] = None
    
    def __post_init__(self):
        self.measurements = self.measurements or []
        self.events = self.events or []


class SimulationLogger:
    """Handles data logging for simulated experiments.
    
    Logs measurements, events, and configuration to both:
    - CSV files for easy analysis
    - JSON for complete state preservation
    
    Args:
        output_dir: Directory for log files
        experiment_id: Unique experiment identifier
    """
    
    def __init__(self, output_dir: Union[str, Path], experiment_id: Optional[str] = None):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        self.experiment_id = experiment_id or datetime.now().strftime("%Y%m%d_%H%M%S")
        self.experiment_dir = self.output_dir / self.experiment_id
        self.experiment_dir.mkdir(exist_ok=True)
        
        self.log = ExperimentLog(
            experiment_id=self.experiment_id,
            start_time=datetime.now(),
            config={}
        )
        
    def log_config(self, config: Dict):
        """Log experiment configuration."""
        self.log.config = config
        self._save_json()
        
    def log_measurement(
        self,
        vial: int,
        od: float,
        temperature: float,
        drug_concentration: float,
        growth_rate: Optional[float] = None,
        action: Optional[str] = None
    ):
        """Log single measurement."""
        measurement = MeasurementLog(
            timestamp=datetime.now(),
            vial=vial,
            od=od,
            temperature=temperature,
            drug_concentration=drug_concentration,
            growth_rate=growth_rate,
            action=action
        )
        self.log.measurements.append(measurement)
        self._append_csv(measurement)
        
    def log_event(self, event_type: str, details: Dict):
        """Log significant event."""
        event = {
            'timestamp': datetime.now().isoformat(),
            'type': event_type,
            **details
        }
        self.log.events.append(event)
        self._save_json()
        
    def _append_csv(self, measurement: MeasurementLog):
        """Append measurement to CSV file."""
        csv_path = self.experiment_dir / 'measurements.csv'
        
        # Convert to dict for pandas
        data = asdict(measurement)
        data['timestamp'] = data['timestamp'].isoformat()
        
        # Create or append to CSV
        df = pd.DataFrame([data])
        if not csv_path.exists():
            df.to_csv(csv_path, index=False)
        else:
            df.to_csv(csv_path, mode='a', header=False, index=False)
            
    def _save_json(self):
        """Save complete log to JSON."""
        json_path = self.experiment_dir / 'experiment.json'
        
        # Convert to serializable format
        data = asdict(self.log)
        data['start_time'] = data['start_time'].isoformat()
        
        for m in data['measurements']:
            m['timestamp'] = m['timestamp'].isoformat()
            
        with open(json_path, 'w') as f:
            json.dump(data, f, indent=2)
            
    def load_measurements(self) -> pd.DataFrame:
        """Load measurements as pandas DataFrame."""
        csv_path = self.experiment_dir / 'measurements.csv'
        if not csv_path.exists():
            return pd.DataFrame()
            
        df = pd.read_csv(csv_path)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        return df
    
    def plot_growth_curves(self):
        """Plot OD and drug concentration over time."""
        import matplotlib.pyplot as plt
        
        df = self.load_measurements()
        if df.empty:
            return
            
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)
        
        # Plot OD
        for vial in df['vial'].unique():
            vial_data = df[df['vial'] == vial]
            ax1.plot(vial_data['timestamp'], vial_data['od'], 
                    label=f'Vial {vial}')
        ax1.set_ylabel('OD')
        ax1.set_yscale('log')
        ax1.legend()
        ax1.grid(True)
        
        # Plot drug concentration
        for vial in df['vial'].unique():
            vial_data = df[df['vial'] == vial]
            ax2.plot(vial_data['timestamp'], vial_data['drug_concentration'],
                    label=f'Vial {vial}')
        ax2.set_ylabel('Drug Concentration')
        ax2.set_xlabel('Time')
        ax2.grid(True)
        
        plt.tight_layout()
        plt.savefig(self.experiment_dir / 'growth_curves.png')
        plt.close() 

--- simulation/src/replifactory_simulation/runner.py ---
from datetime import datetime
from replifactory_core.protocols import MorbidostatProtocol, MorbidostatConfig
from dataclasses import asdict
import logging
from threading import Thread
from typing import Optional
import time
from replifactory_core.base_device import BaseDevice
from replifactory_core.experiment import ExperimentConfig, Experiment
from replifactory_simulation.simulation_factory import SimulationFactory
from replifactory_simulation.growth_model import GrowthModelParameters
from replifactory_simulation.logging import SimulationLogger, MeasurementLog


from .simulation_factory import SimulationFactory
from .growth_model import GrowthModelParameters
from .logging import SimulationLogger
import time
from threading import Thread, Event
from typing import Optional
import logging
from flask_sqlalchemy import SQLAlchemy
from replifactory_server.database_models import db, MeasurementData
from dataclasses import asdict

db = SQLAlchemy()
logger = logging.getLogger(__name__)

class SimulationRunner:
    """Runs simulated evolution experiments."""
    
    def __init__(
        self,
        config: ExperimentConfig = ExperimentConfig(),
        model_params: Optional[GrowthModelParameters] = None,
        time_acceleration: float = 100.0,
        device: Optional[BaseDevice] = None,
        app=None,
        db=None,  # Add database parameter
        measurement_model=None  # Add measurement model parameter
    ):
        self._log = logging.getLogger("SimulationRunner")
        self.time_acceleration = time_acceleration
        self.config = config
        self.model_params = model_params or GrowthModelParameters()  # Store model_params
        self._running = False
        self._thread: Optional[Thread] = None
        self.app = app
        self.db = db  # Store database reference
        self.measurement_model = measurement_model  # Store measurement model reference
        
        # Create device if not provided
        if device is None:
            factory = SimulationFactory()
            device = factory.create_device(config.device_config, self.model_params)
        self.device = device
        
        # Initialize protocol
        self.protocol = MorbidostatProtocol(MorbidostatConfig())
        
        # Initialize experiment
        self.experiment = Experiment(
            device=self.device,
            config=self.config,
            protocol=self.protocol
        )
        
        # Initialize data logging
        self.data_logger = SimulationLogger(
            output_dir="data/experiments",
            experiment_id=self.experiment.name
        )
        self.data_logger.log_config(asdict(config))
        
    def start(self):
        if self._thread is not None and self._thread.is_alive():
            self._log.warning("Simulation already running")
            return
            
        self._running = True
        
        # Log initial state
        self.data_logger.log_config({
            'experiment': self.config.__dict__,
            'growth_model': self.model_params.__dict__,
            'time_acceleration': self.time_acceleration
        })
        
        # Start experiment
        self._log.info("Starting experiment...")
        self.experiment.start()
        
        # Take initial measurements
        self._log.info("Taking initial measurements...")
        try:
            self._update_simulation()
        except Exception as e:
            self._log.error(f"Error taking initial measurements: {str(e)}")
            self.experiment.stop()
            return
            
        # Start simulation thread
        self._thread = Thread(
            target=self._run_simulation,
            name="SimulationThread",
            daemon=True
        )
        self._thread.start()
        self._log.info("Simulation started")
        
    def stop(self):
        self._log.info("Stopping simulation...")
        self._running = False
        
        if self._thread and self._thread.is_alive():
            # Wait with timeout
            self._thread.join(timeout=5.0)
            if self._thread.is_alive():
                self._log.warning("Simulation thread did not stop cleanly")
        
        self._thread = None
        self.experiment.stop()
        self._log.info("Simulation stopped")
        
    def _run_simulation(self):
        try:
            update_interval = self.config.measurement_interval_mins * 60  # seconds
            update_interval /= self.time_acceleration
            
            self._last_update = time.time()
            self._log.info(f"Update interval: {update_interval:.2f} seconds")
            
            while self._running and self.experiment._status == "running":
                current_time = time.time()
                elapsed = current_time - self._last_update
                
                if elapsed >= update_interval:
                    self._log.debug(f"Running update at {current_time}")
                    try:
                        self._update_simulation()
                        self._last_update = current_time
                    except Exception as e:
                        self._log.error(f"Update error: {e}")
                        if not isinstance(e, (ValueError, RuntimeError)):
                            raise
                
                # Prevent CPU spinning while checking more frequently
                time.sleep(min(0.1, update_interval / 10))
                
        except Exception as e:
            self._log.error(f"Simulation error: {e}")
            self.data_logger.log_event('error', {'message': str(e)})
        finally:
            if self.experiment._status != "stopped":
                self.experiment.stop()
                
    def _update_simulation(self):
        """Update simulation state and record measurements."""
        # Update growth models
        od_sensor = self.device._od_sensor
        for vial in range(1, self.config.device_config.n_vials + 1):
            model = od_sensor._growth_models[vial]
            timestep = self.config.measurement_interval_mins / self.time_acceleration
            model.update(timestep_mins=timestep)
        
        # Update experiment
        self.experiment.update()
        
        # Log status
        status = self.experiment.status
        for vial, data in status['cultures'].items():
            if data is None:
                self._log.warning(f"No data for vial {vial}")
                continue
                
            # Extract values with safe defaults
            od = data.get('od', 0.0)
            drug_conc = data.get('drug_concentration', 0.0)
            growth_rate = data.get('growth_rate', 0.0)
            temp = data.get('temperature', 37.0)
            
            # Log status
            self._log.info(
                f"Vial {vial}: OD={od:.3f}, Drug={drug_conc:.1f}, "
                f"Growth Rate={growth_rate:.3f}/hr"
            )
            
            # Save to database if app context is available
            if self.app and self.db and self.measurement_model and hasattr(self.experiment, 'model'):
                try:
                    with self.app.app_context():
                        measurement = self.measurement_model(
                            experiment_id=self.experiment.model.id,
                            vial=vial,
                            timestamp=datetime.now(),
                            od=od,
                            temperature=temp,
                            drug_concentration=drug_conc,
                            growth_rate=growth_rate
                        )
                        self.db.session.add(measurement)
                        self.db.session.commit()
                        self._log.debug(f"Saved measurement for vial {vial} to database")
                except Exception as e:
                    self._log.error(f"Failed to save measurement to database: {str(e)}")
            
            # Record measurement in data logger
            self.data_logger.log_measurement(
                vial=vial,
                od=od,
                temperature=temp,
                drug_concentration=drug_conc,
                growth_rate=growth_rate,
                action=data.get('last_action')
            )
        
        if status.get('error'):
            self._log.error(f"Experiment error: {status['error']}")
            self.data_logger.log_event('error', {'message': status['error']})


--- simulation/src/replifactory_simulation/simulation_factory.py ---
from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface
)
from replifactory_core.base_device import BaseDevice, BaseDeviceConfig
from replifactory_core.factory import DeviceComponentFactory

from .devices import (
    SimulatedPump, SimulatedValves, SimulatedStirrer,
    SimulatedODSensor, SimulatedThermometer
)


class SimulationFactory(DeviceComponentFactory):
    def __init__(self, monitor=None):
        self.monitor = monitor

    def create_pump(self, pump_number: int) -> PumpInterface:
        return SimulatedPump(
            pump_number=pump_number,
            event_listener=self.monitor
        )
    
    def create_valves(self) -> ValveInterface:
        return SimulatedValves(event_listener=self.monitor)
    
    def create_stirrer(self) -> StirrerInterface:
        return SimulatedStirrer()
    
    def create_od_sensor(self) -> ODSensorInterface:
        return SimulatedODSensor()
    
    def create_thermometer(self) -> ThermometerInterface:
        return SimulatedThermometer()


def create_simulated_device(config: BaseDeviceConfig = None, monitor=None) -> BaseDevice:
    if config is None:
        config = BaseDeviceConfig()
    
    factory = SimulationFactory(monitor=monitor)
    
    return BaseDevice(
        config=config,
        pumps={
            1: factory.create_pump(1),  # Media
            2: factory.create_pump(2),  # Drug
            4: factory.create_pump(4)   # Waste
        },
        valves=factory.create_valves(),
        stirrer=factory.create_stirrer(),
        od_sensor=factory.create_od_sensor(),
        thermometer=factory.create_thermometer()
    )

--- simulation/tests/.gitkeep ---


--- simulation/tests/simple_test.py ---
import pytest
import numpy as np
from replifactory_core.base_device import BaseDeviceConfig
from replifactory_simulation.simulation_factory import create_simulated_device
from replifactory_core.interfaces import DeviceError, StirrerSpeed




@pytest.fixture
def device():
    return create_simulated_device()


def test_device_creation():
    device = create_simulated_device()
    assert device is not None
    
    # Check required components exist
    assert 1 in device._pumps  # Media pump
    assert 2 in device._pumps  # Drug pump
    assert 4 in device._pumps  # Waste pump
    assert device._valves is not None
    assert device._stirrer is not None
    assert device._od_sensor is not None
    assert device._thermometer is not None


def test_vial_measurements(device):
    # Test valid measurement
    measurements = device.measure_vial(1)
    assert measurements.od >= 0
    assert 20 <= measurements.temperature <= 45  # Reasonable temp range
    assert measurements.rpm is not None
    
    # Test invalid vial number
    with pytest.raises(ValueError):
        device.measure_vial(8)
    with pytest.raises(ValueError):
        device.measure_vial(0)


def test_dilution_operation(device):
    # Valid dilution
    device.make_dilution(1, media_volume=5.0, drug_volume=0.5)
    
    # Test volume limits
    with pytest.raises(ValueError):
        device.make_dilution(1, media_volume=50.0, drug_volume=0.5)  # Too much volume
        
    # Test invalid vial
    with pytest.raises(ValueError):
        device.make_dilution(8, media_volume=5.0, drug_volume=0.5)


def test_pump_behavior(device):
    pump = device._pumps[1]
    
    # Test pumping
    initial_volume = pump.pumped_volume
    test_volume = 5.0
    pump.pump(test_volume)
    assert pump.pumped_volume == initial_volume + test_volume
    assert not pump.is_pumping
    
    # Test concurrent pumping prevention
    with pytest.raises(DeviceError):
        pump.pump(1.0)
        pump.pump(1.0)  # Should fail - pump busy


def test_valve_operations(device):
    valves = device._valves
    
    # Test open/close
    valves.open(1)
    assert valves.is_open(1)
    valves.close(1)
    assert not valves.is_open(1)
    
    # Test close_all
    valves.open(1)
    valves.open(2)
    valves.close_all()
    assert not any(valves.is_open(v) for v in range(1, 8))


def test_stirrer_control(device):
    stirrer = device._stirrer
    
    # Test speed setting
    stirrer.set_speed(1, StirrerSpeed.HIGH)
    rpm = stirrer.measure_rpm(1)
    assert rpm > 0
    
    stirrer.set_speed(1, StirrerSpeed.STOPPED)
    rpm = stirrer.measure_rpm(1)
    assert rpm == 0
    
    # Test emergency stop
    stirrer.set_speed(1, StirrerSpeed.HIGH)
    stirrer.stop_all()
    rpm = stirrer.measure_rpm(1)
    assert rpm == 0


def test_od_sensor(device):
    sensor = device._od_sensor
    
    # Test OD measurement
    od, signal = sensor.measure_od(1)
    assert od >= 0
    assert signal > 0
    
    # Test blank measurement
    blank = sensor.measure_blank(1)
    assert blank > 0


def test_temperature_monitoring(device):
    temps = device._thermometer.measure_temperature()
    
    assert 'vials' in temps
    assert 'board' in temps
    assert 20 <= temps['vials'] <= 45
    assert 20 <= temps['board'] <= 45


def test_vial_status(device):
    status = device.vial_status
    
    # Check all vials present
    assert all(v in status for v in range(1, 8))
    
    # Check required measurements
    for v in range(1, 8):
        assert 'od' in status[v]
        assert 'temperature' in status[v]
        assert 'rpm' in status[v]


def test_emergency_stop(device):
    # Set up some activity
    device._valves.open(1)
    device._stirrer.set_speed(1, StirrerSpeed.HIGH)
    
    # Emergency stop
    device.emergency_stop()
    
    # Verify everything stopped
    assert not device._valves.is_open(1)
    assert device._stirrer.measure_rpm(1) == 0
    assert not any(pump.is_pumping for pump in device._pumps.values())


def test_growth_simulation(device):
    # Initial measurement
    m1 = device.measure_vial(1)
    initial_od = m1.od
    
    # Make dilution and verify OD decreases
    device.make_dilution(1, media_volume=5.0, drug_volume=0.0)
    m2 = device.measure_vial(1)
    assert m2.od < initial_od
    
    # Add drug and verify growth impact
    device.make_dilution(1, media_volume=0.0, drug_volume=5.0)
    m3 = device.measure_vial(1)
    status = device.vial_status

--- tools/gitkeep_dirs.py ---
import os

def add_gitkeep_to_empty_dirs(base_path):
    """Recursively add .gitkeep to every empty directory under the base path."""
    for root, dirs, files in os.walk(base_path):
        for directory in dirs:
            dir_path = os.path.join(root, directory)
            if not os.listdir(dir_path):  # Check if the directory is empty
                gitkeep_path = os.path.join(dir_path, '.gitkeep')
                with open(gitkeep_path, 'w') as f:
                    pass  # Create an empty .gitkeep file
                print(f"Added .gitkeep to: {dir_path}")

if __name__ == "__main__":
    base_path = os.getcwd()  # Change to the desired base path if needed
    add_gitkeep_to_empty_dirs(base_path)


--- ui/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Replifactory Monitor</title>
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: "Avenir", Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
        }
        
        .nav-drawer {
            width: 250px;
            background: #1E1E1E;
            color: white;
            padding: 20px;
            transition: width 0.3s;
        }
        
        .nav-drawer.collapsed {
            width: 64px;
        }
        
        .main-content {
            flex-grow: 1;
            padding: 20px;
            background: #f5f5f5;
        }
        i se
        .nav-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .nav-item.active {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .nav-item i {
            margin-right: 12px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            height: 600px;
            width: 100%;
        }
        
        .status-bar {
            background: #333;
            color: white;
            padding: 10px;
            position: fixed;
            bottom: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
        }

        /* Add vial card styles */
        .vials-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .vial-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .vial-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .vial-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .measurement {
            margin: 5px 0;
            color: #34495e;
        }

        /* Pump animation styles */
        .pumps-container {
            display: flex;
            justify-content: center;
            gap: 40px;
            padding: 40px;
            margin-top: 20px;
        }

        .pump {
            text-align: center;
        }

        .pump-body {
            width: 100px;
            height: 200px;
            background: #e0e0e0;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            border: 2px solid #999;
        }

        .pump-label {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            color: #333;
        }

        .pump-piston {
            width: 80px;
            height: 40px;
            background: #666;
            position: absolute;
            left: 10px;
            bottom: 10px;
            transition: transform 0.5s ease-in-out;
            border-radius: 5px;
        }

        .pump-status {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .pump.active .pump-piston {
            animation: pump 1s infinite;
        }

        @keyframes pump {
            0% { transform: translateY(0); }
            50% { transform: translateY(-140px); }
            100% { transform: translateY(0); }
        }

        /* Valve styles */
        .valves-container {
            display: flex;
            justify-content: center;
            gap: 40px;
            padding: 20px;
            margin-top: 20px;
        }

        .valve {
            text-align: center;
        }

        .valve-body {
            width: 80px;
            height: 80px;
            background: #e0e0e0;
            border-radius: 50%;
            position: relative;
            border: 2px solid #999;
            overflow: hidden;
        }

        .valve-label {
            position: absolute;
            top: 5px;
            width: 100%;
            text-align: center;
            font-weight: bold;
            color: #333;
        }

        .valve-handle {
            width: 8px;
            height: 40px;
            background: #666;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) rotate(0deg);
            transform-origin: center;
            transition: transform 0.3s ease-in-out;
            border-radius: 4px;
        }

        .valve-status {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .valve.open .valve-handle {
            transform: translate(-50%, -50%) rotate(90deg);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="nav-drawer" id="nav-drawer">
            <div class="nav-item" onclick="selectTab('experiment')" id="tab-experiment">
                <i class="mdi mdi-flask"></i>
                <span>Experiment</span>
            </div>
            <div class="nav-item" onclick="selectTab('animation')" id="tab-animation">
                <i class="mdi mdi-pump"></i>
                <span>Animation</span>
            </div>
            <div class="nav-item" onclick="selectTab('prediction')" id="tab-prediction">
                <i class="mdi mdi-chart-bell-curve-cumulative"></i>
                <span>Prediction</span>
            </div>
            <div class="nav-item" onclick="selectTab('device')" id="tab-device">
                <i class="mdi mdi-robot-industrial"></i>
                <span>Device Control</span>
            </div>
            <div class="nav-item" onclick="selectTab('remote')" id="tab-remote">
                <i class="mdi mdi-remote-desktop"></i>
                <span>Remote</span>
            </div>
            <div class="nav-item" onclick="selectTab('docs')" id="tab-docs">
                <i class="mdi mdi-book-open-variant"></i>
                <span>Docs</span>
            </div>
            <div class="nav-item" onclick="selectTab('status')" id="tab-status">
                <i class="mdi mdi-monitor-eye"></i>
                <span>Status</span>
            </div>
            <div class="nav-item" onclick="selectTab('logs')" id="tab-logs">
                <i class="mdi mdi-file-document-alert-outline"></i>
                <span>Logs</span>
            </div>
        </div>
        
        <div class="main-content">
            <div id="experiment-tab" class="tab-content">
                <div class="vials-container" id="vials"></div>
                <div class="chart-container">
                    <canvas id="odChart"></canvas>
                </div>
                <div id="no-data" style="text-align: center; color: #666;"></div>
            </div>
            <div id="animation-tab" class="tab-content" style="display: none;">
                <div class="pumps-container">
                    <div class="pump" id="pump-1">
                        <div class="pump-body">
                            <div class="pump-label">Pump 1</div>
                            <div class="pump-piston"></div>
                        </div>
                        <div class="pump-status">Idle</div>
                    </div>
                    <div class="pump" id="pump-2">
                        <div class="pump-body">
                            <div class="pump-label">Pump 2</div>
                            <div class="pump-piston"></div>
                        </div>
                        <div class="pump-status">Idle</div>
                    </div>
                </div>
                <div class="valves-container">
                    <div class="valve" id="valve-1">
                        <div class="valve-body">
                            <div class="valve-label">Valve 1</div>
                            <div class="valve-handle"></div>
                        </div>
                        <div class="valve-status">Closed</div>
                    </div>
                    <div class="valve" id="valve-2">
                        <div class="valve-body">
                            <div class="valve-label">Valve 2</div>
                            <div class="valve-handle"></div>
                        </div>
                        <div class="valve-status">Closed</div>
                    </div>
                </div>
            </div>
            <div id="device-tab" class="tab-content" style="display: none;">
                <div style="max-width: 600px; margin: 20px auto; padding: 20px;">
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h2 style="margin-bottom: 20px; color: #2c3e50;">Pump Control</h2>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">Select Pump:</label>
                            <select id="pumpSelect" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="1">Pump 1</option>
                                <option value="2">Pump 2</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">Volume (mL):</label>
                            <input type="number" id="pumpVolume" min="0" step="0.1" value="1.0" 
                                   style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                        </div>
                        <button onclick="activatePump()" 
                                style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; width: 100%;">
                            Start Pump
                        </button>
                    </div>

                    <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h2 style="margin-bottom: 20px; color: #2c3e50;">Valve Control</h2>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">Select Valve:</label>
                            <select id="valveSelect" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="1">Valve 1</option>
                                <option value="2">Valve 2</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px;">State:</label>
                            <select id="valveState" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="open">Open</option>
                                <option value="closed">Closed</option>
                            </select>
                        </div>
                        <button onclick="setValveState()" 
                                style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; width: 100%;">
                            Set Valve State
                        </button>
                    </div>
                </div>
            </div>
            <!-- Other tab contents will be added here -->
        </div>
    </div>
    
    <div class="status-bar">
        <div id="connection-status">Connecting to server...</div>
        <div id="experiment-status"></div>
    </div>

    <!-- Add tab handling script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tab handling
            function selectTab(tabName) {
                // Remove active class from all tabs
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Add active class to selected tab
                const selectedTab = document.getElementById(`tab-${tabName}`);
                if (selectedTab) {
                    selectedTab.classList.add('active');
                }
                
                // Hide all tab contents
                document.querySelectorAll('.tab-content').forEach(content => {
                    if (content) {
                        content.style.display = 'none';
                    }
                });
                
                // Show selected tab content
                const selectedContent = document.getElementById(`${tabName}-tab`);
                if (selectedContent) {
                    selectedContent.style.display = 'block';
                }
            }
    
            // Make selectTab available globally
            window.selectTab = selectTab;
            
            // Initialize Socket.IO connection
            const socket = io('http://localhost:5000', {
                transports: ['websocket', 'polling'],
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: 10
            });

            // Get DOM elements
            const statusElement = document.getElementById('connection-status');
            const noDataElement = document.getElementById('no-data');
            
            // Initialize data structures
            let vialData = {};
            let timeSeriesData = {};
            let odChart;

            // Initialize Chart.js
            function initializeChart() {
                console.log('Initializing chart...');
                if (odChart) {
                    console.log('Destroying existing chart');
                    odChart.destroy();
                }
                const ctx = document.getElementById('odChart').getContext('2d');
                odChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        elements: {
                            line: { tension: 0.1 },
                            point: { radius: 3 }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'OD Measurements Over Time'
                            },
                            legend: { position: 'top' }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'second',
                                    displayFormats: { second: 'HH:mm:ss' }
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                type: 'linear',
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'OD'
                                },
                                ticks: { 
                                    precision: 3,
                                    stepSize: 0.001
                                }
                            }
                        }
                    }
                });
                timeSeriesData = {};
                console.log('Chart initialized');
            }

            // Function to update chart ranges
            function updateChartRanges() {
                if (!odChart || Object.keys(timeSeriesData).length === 0) return;

                // Get all OD values
                const allODs = Object.values(timeSeriesData)
                    .flat()
                    .map(point => point.y);

                // Calculate min and max with padding
                const minOD = Math.min(...allODs);
                const maxOD = Math.max(...allODs);
                const range = maxOD - minOD;
                const padding = Math.max(range * 0.1, 0.001); // Ensure minimum padding

                // Update Y axis with minimum range
                const yMin = Math.max(0, minOD - padding);
                const yMax = maxOD + padding;
                
                // Ensure minimum range of 0.1 if values are very small
                const minRange = 0.1;
                if ((yMax - yMin) < minRange) {
                    odChart.options.scales.y.max = yMin + minRange;
                } else {
                    odChart.options.scales.y.max = yMax;
                }
                odChart.options.scales.y.min = yMin;

                // Get all timestamps
                const allTimes = Object.values(timeSeriesData)
                    .flat()
                    .map(point => point.x.getTime());

                // Update X axis with padding
                const minTime = Math.min(...allTimes);
                const maxTime = Math.max(...allTimes);
                const timeRange = maxTime - minTime;
                const timePadding = timeRange * 0.05;
                odChart.options.scales.x.min = new Date(minTime - timePadding);
                odChart.options.scales.x.max = new Date(maxTime + timePadding);
            }

            // Update vial display
            function updateVialDisplay(data) {
                const vialId = data.vial;
                vialData[vialId] = data;

                // Hide no-data message if we have data
                noDataElement.style.display = 'none';

                // Update or create vial card
                let vialElement = document.getElementById(`vial-${vialId}`);
                if (!vialElement) {
                    vialElement = document.createElement('div');
                    vialElement.id = `vial-${vialId}`;
                    vialElement.className = 'vial-card';
                    document.getElementById('vials').appendChild(vialElement);
                }

                vialElement.innerHTML = `
                    <div class="vial-title">Vial ${vialId}</div>
                    <div class="measurement">OD: ${data.od.toFixed(3)}</div>
                    <div class="measurement">Temperature: ${data.temperature.toFixed(1)}°C</div>
                    ${data.drug_concentration !== null ? `<div class="measurement">Drug Concentration: ${data.drug_concentration.toFixed(2)}</div>` : ''}
                    ${data.growth_rate !== null ? `<div class="measurement">Growth Rate: ${data.growth_rate.toFixed(3)}/hr</div>` : ''}
                    <div class="measurement">Last Update: ${new Date(data.timestamp).toLocaleTimeString()}</div>
                `;
            }

            // Handle vial updates
            socket.on('vial_update', (data) => {
                console.log('Received vial update:', data);
                const vialId = data.vial;

                if (!odChart) {
                    console.error('Chart not initialized, initializing now...');
                    initializeChart();
                }

                try {
                    // Initialize dataset if it doesn't exist
                    if (!timeSeriesData[vialId]) {
                        console.log(`Initializing dataset for vial ${vialId}`);
                        timeSeriesData[vialId] = [];
                        odChart.data.datasets.push({
                            label: `Vial ${vialId}`,
                            data: [],
                            borderColor: `hsl(${vialId * 137.5}, 70%, 50%)`,
                            backgroundColor: `hsla(${vialId * 137.5}, 70%, 50%, 0.1)`,
                            fill: false
                        });
                    }

                    // Create the new data point
                    const timestamp = new Date(data.timestamp);
                    const newPoint = {
                        x: timestamp,
                        y: parseFloat(data.od)
                    };
                    console.log(`Adding point for vial ${vialId}:`, newPoint);

                    // Add the point to our time series data
                    timeSeriesData[vialId].push(newPoint);

                    // Keep only the last 100 points to prevent memory issues
                    if (timeSeriesData[vialId].length > 100) {
                        timeSeriesData[vialId] = timeSeriesData[vialId].slice(-100);
                    }

                    // Update the chart dataset
                    const datasetIndex = odChart.data.datasets.findIndex(ds => ds.label === `Vial ${vialId}`);
                    if (datasetIndex !== -1) {
                        odChart.data.datasets[datasetIndex].data = [...timeSeriesData[vialId]];
                    }

                    // Update axis ranges
                    updateChartRanges();

                    // Force chart update with animation disabled for better performance
                    odChart.update('none');

                    // Update vial display
                    updateVialDisplay(data);
                } catch (error) {
                    console.error('Error updating chart:', error);
                }
            });

            // Add auto-refresh function that fetches new data
            async function refreshChart() {
                if (!odChart) return;
                
                try {
                    // Fetch updated data for each vial
                    for (let vial = 1; vial <= 2; vial++) {
                        const plotResponse = await fetch(`http://localhost:5000/plot/${vial}`);
                        if (plotResponse.ok) {
                            const plotData = await plotResponse.json();
                            
                            // Convert data to chart format
                            timeSeriesData[vial] = plotData.times.map((time, index) => ({
                                x: new Date(time),
                                y: plotData.ods[index]
                            }));

                            // Update the dataset
                            const datasetIndex = odChart.data.datasets.findIndex(ds => ds.label === `Vial ${vial}`);
                            if (datasetIndex !== -1) {
                                odChart.data.datasets[datasetIndex].data = [...timeSeriesData[vial]];
                            }
                        }
                    }

                    // Update axis ranges and refresh chart
                    updateChartRanges();
                    odChart.update('none');
                    console.log('Chart refreshed with new data');
                } catch (error) {
                    console.error('Error refreshing chart:', error);
                }
            }

            // Set up auto-refresh interval (every 5 seconds)
            setInterval(refreshChart, 5000);

            // Socket.IO event handlers
            socket.on('connect', () => {
                console.log('Connected to server');
                statusElement.className = 'status-indicator status-connected';
                statusElement.textContent = 'Connected to server';
                getActiveExperiment();
            });

            socket.on('connect_error', (error) => {
                console.error('Connection error:', error);
                statusElement.className = 'status-indicator status-disconnected';
                statusElement.textContent = `Connection error: ${error.message}`;
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                statusElement.className = 'status-indicator status-disconnected';
                statusElement.textContent = 'Disconnected from server';
            });

            socket.on('reconnecting', (attemptNumber) => {
                console.log(`Attempting to reconnect (${attemptNumber})`);
                statusElement.className = 'status-indicator status-connecting';
                statusElement.textContent = `Reconnecting (attempt ${attemptNumber})...`;
            });

            // Add function to get active experiment
            async function getActiveExperiment() {
                try {
                    console.log('Fetching active experiment...');
                    const response = await fetch('http://localhost:5000/experiments/active', {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('Active experiment data:', data);
                    
                    if (data.experiment) {
                        console.log('Active experiment:', data.experiment);
                        noDataElement.textContent = `Monitoring experiment ${data.experiment.id}: ${data.experiment.name}`;
                        
                        // Initialize chart once
                        if (!odChart) {
                            initializeChart();
                        }
                        
                        // Fetch initial data for each vial
                        for (let vial = 1; vial <= 2; vial++) {
                            const plotResponse = await fetch(`http://localhost:5000/plot/${vial}`);
                            if (plotResponse.ok) {
                                const plotData = await plotResponse.json();
                                console.log(`Initial data for vial ${vial}:`, plotData);
                                
                                // Convert data to chart format
                                timeSeriesData[vial] = plotData.times.map((time, index) => ({
                                    x: new Date(time),
                                    y: plotData.ods[index]
                                }));
                                
                                // Check if dataset already exists
                                const existingDatasetIndex = odChart.data.datasets.findIndex(ds => ds.label === `Vial ${vial}`);
                                if (existingDatasetIndex === -1) {
                                    // Only add dataset if it doesn't exist
                                    odChart.data.datasets.push({
                                        label: `Vial ${vial}`,
                                        data: timeSeriesData[vial],
                                        borderColor: `hsl(${vial * 137.5}, 70%, 50%)`,
                                        backgroundColor: `hsla(${vial * 137.5}, 70%, 50%, 0.1)`,
                                        fill: false
                                    });
                                } else {
                                    // Update existing dataset
                                    odChart.data.datasets[existingDatasetIndex].data = timeSeriesData[vial];
                                }
                            }
                        }
                        
                        // Update chart with initial data
                        odChart.update();
                    } else {
                        console.log('No active experiment found');
                        noDataElement.textContent = 'No active experiment';
                    }
                } catch (error) {
                    console.error('Error fetching active experiment:', error);
                    noDataElement.textContent = 'Error fetching experiment info';
                    statusElement.className = 'status-indicator status-disconnected';
                    statusElement.textContent = `Connection error: ${error.message}`;
                }
            }

            // Handle pump events
            socket.on('pump_status', (data) => {
                const pumpElement = document.getElementById(`pump-${data.pump}`);
                if (pumpElement) {
                    const statusElement = pumpElement.querySelector('.pump-status');
                    
                    if (data.active) {
                        pumpElement.classList.add('active');
                        statusElement.textContent = 'Pumping...';
                    } else {
                        pumpElement.classList.remove('active');
                        statusElement.textContent = 'Idle';
                    }
                }
            });

            // Handle valve events
            socket.on('valve_status', (data) => {
                const valveElement = document.getElementById(`valve-${data.valve}`);
                if (valveElement) {
                    const statusElement = valveElement.querySelector('.valve-status');
                    
                    if (data.open) {
                        valveElement.classList.add('open');
                        statusElement.textContent = 'Open';
                    } else {
                        valveElement.classList.remove('open');
                        statusElement.textContent = 'Closed';
                    }
                }
            });

            // Initialize with experiment tab selected
            selectTab('experiment');

            // Add device control functions
            async function activatePump() {
                const pumpId = document.getElementById('pumpSelect').value;
                const volume = document.getElementById('pumpVolume').value;
                
                try {
                    const response = await fetch('http://localhost:5000/device/pump', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        mode: 'cors',
                        credentials: 'omit',
                        body: JSON.stringify({
                            pump: parseInt(pumpId),
                            volume: parseFloat(volume)
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log(`Pump activation result:`, result);
                    alert(`Success: ${result.message}`);
                } catch (error) {
                    console.error('Error activating pump:', error);
                    alert('Error activating pump: ' + error.message);
                }
            }

            async function setValveState() {
                const valveId = document.getElementById('valveSelect').value;
                const state = document.getElementById('valveState').value;
                
                try {
                    const response = await fetch('http://localhost:5000/device/valve', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        mode: 'cors',
                        credentials: 'omit',
                        body: JSON.stringify({
                            valve: parseInt(valveId),
                            state: state === 'open'
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log(`Valve state change result:`, result);
                    alert(`Success: ${result.message}`);
                } catch (error) {
                    console.error('Error setting valve state:', error);
                    alert('Error setting valve state: ' + error.message);
                }
            }

            // Make functions globally available
            window.activatePump = activatePump;
            window.setValveState = setValveState;
        });
    </script>

    <!-- Existing scripts -->
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    
    <!-- Your existing JavaScript code here -->
</body>
</html> 

--- ui/pyproject.toml ---


--- ui/serve.py ---
from http.server import HTTPServer, SimpleHTTPRequestHandler
import os
import sys

def run(port=8000):
    """Run the HTTP server on the specified port."""
    server_address = ('', port)
    httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
    print(f"Starting UI server on port {port}")
    print(f"Open http://localhost:{port} in your browser")
    httpd.serve_forever()

if __name__ == '__main__':
    # Change to the directory containing this script
    os.chdir(os.path.dirname(os.path.abspath(__file__)))
    
    # Get port from command line argument or use default
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
    run(port) 

--- ui/tests/.gitkeep ---

