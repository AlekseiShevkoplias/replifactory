Repository: replifactory

File Tree:
└── .gitignore
└── README.md
└── core/pyproject.toml
└── core/src/replifactory_core/__init__.py
└── core/src/replifactory_core/base_device.py
└── core/src/replifactory_core/culture.py
└── core/src/replifactory_core/experiment.py
└── core/src/replifactory_core/factory.py
└── core/src/replifactory_core/interfaces.py
└── core/src/replifactory_core/parameters.py
└── core/src/replifactory_core/protocols.py
└── core/src/replifactory_core/types.py
└── core/tests/.gitkeep
└── docs/developer-guide/.gitkeep
└── docs/index.md
└── docs/user-guide/.gitkeep
└── hardware/pyproject.toml
└── hardware/tests/.gitkeep
└── mkdocs.yml
└── nx.json
└── server/pyproject.toml
└── server/src/replifactory_server/.gitkeep
└── server/tests/.gitkeep
└── simulation/examples/quick_start.py
└── simulation/examples/run_simulation.py
└── simulation/pyproject.toml
└── simulation/src/replifactory_simulation/.gitkeep
└── simulation/src/replifactory_simulation/__init__.py
└── simulation/src/replifactory_simulation/devices.py
└── simulation/src/replifactory_simulation/factory.py
└── simulation/src/replifactory_simulation/growth_model.py
└── simulation/src/replifactory_simulation/logging.py
└── simulation/src/replifactory_simulation/runner.py
└── simulation/src/replifactory_simulation/simulation_factory.py
└── simulation/tests/.gitkeep
└── simulation/tests/simple_test.py
└── tools/gitkeep_dirs.py
└── ui/pyproject.toml
└── ui/tests/.gitkeep

File Contents:

--- .gitignore ---
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# PyPI configuration file
.pypirc


# Project-specific
misc/
old_version/
simulation_logs/
context.txt


--- README.md ---
# replifactory

--- core/pyproject.toml ---


--- core/src/replifactory_core/__init__.py ---


--- core/src/replifactory_core/base_device.py ---
from dataclasses import dataclass
from typing import Dict, Optional

import numpy as np 

from .interfaces import (
    ExperimentDeviceInterface,
    PumpInterface,
    ValveInterface,
    StirrerInterface,
    ODSensorInterface,
    ThermometerInterface,
    VialMeasurements,
    DeviceError
)

from .parameters import *


@dataclass
class BaseDeviceConfig:
    """Configuration for BaseDevice.
    
    Attributes:
        n_vials: Number of vials in device
        max_volume_ml: Maximum vial volume in ml
        min_volume_ml: Minimum operating volume in ml
    """
    n_vials: int = 7
    max_volume_ml: float = 30.0
    min_volume_ml: float = 5.0


class BaseDevice(ExperimentDeviceInterface):
    """Base implementation of experiment device control.
    
    Coordinates multiple device components to perform experiment operations.
    All hardware-specific implementation is delegated to injected components.
    
    Args:
        config: Device configuration
        pumps: Dict mapping pump numbers to pump interfaces
        valves: Valve control interface
        stirrer: Stirrer control interface
        od_sensor: OD measurement interface
        thermometer: Temperature measurement interface
    """
    
    def __init__(
        self,
        config: BaseDeviceConfig,
        pumps: Dict[int, PumpInterface],
        valves: ValveInterface,
        stirrer: StirrerInterface,
        od_sensor: ODSensorInterface,
        thermometer: ThermometerInterface,
    ):
        self.config = config
        self._pumps = pumps
        self._valves = valves
        self._stirrer = stirrer
        self._od_sensor = od_sensor
        self._thermometer = thermometer
        
        # Validate configuration
        self._validate_components()

    def _validate_components(self) -> None:
        """Validate device configuration and components.
        
        Raises:
            ValueError: If configuration is invalid
            DeviceError: If components are missing or misconfigured
        """
        if not (1 <= self.config.n_vials <= 7):
            raise ValueError(f"Invalid number of vials: {self.config.n_vials}")
            
        required_pumps = {1, 2, 4}  # Media, drug, waste
        if not all(p in self._pumps for p in required_pumps):
            raise DeviceError(f"Missing required pumps: {required_pumps - set(self._pumps)}")

    def measure_vial(self, vial: int) -> VialMeasurements:
        """Get all measurements for a specific vial.
        
        Coordinates multiple measurements while handling stirrer speed.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            VialMeasurements with all available data
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If critical measurements fail
        """
        if not 1 <= vial <= self.config.n_vials:
            raise ValueError(f"Invalid vial number: {vial}")
            
        try:
            # Set stirrer to measurement speed
            self._stirrer.set_speed(vial, "low")
            
            # Take measurements
            od, signal = self._od_sensor.measure_od(vial)
            temp = self._thermometer.measure_temperature()['vials']
            rpm = self._stirrer.measure_rpm(vial)
            
            # Restore stirrer speed
            self._stirrer.set_speed(vial, "high")
            
            return VialMeasurements(
                od=od,
                temperature=temp,
                rpm=rpm
            )
            
        except Exception as e:
            # Ensure stirrer restored on error
            self._stirrer.set_speed(vial, "high")
            raise DeviceError(f"Measurement failed: {str(e)}")

    def make_dilution(self, vial: int, media_volume: float, drug_volume: float) -> None:
        """Perform dilution operation on specific vial.
        
        Args:
            vial: Vial number (1-7)
            media_volume: Volume of fresh media to add in ml
            drug_volume: Volume of drug solution to add in ml
            
        Raises:
            ValueError: If parameters invalid
            DeviceError: If operation fails
        """
        if not 1 <= vial <= self.config.n_vials:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Validate volumes
        total_volume = media_volume + drug_volume
        if total_volume > self.config.max_volume_ml:
            raise ValueError(f"Total volume {total_volume} exceeds maximum {self.config.max_volume_ml}")
            
        try:
            # Calculate new drug concentration
            current_volume = 12.0  # TODO: Get from config
            total_volume = current_volume + media_volume + drug_volume
            
            if hasattr(self._od_sensor, 'update_drug_concentration'):
                new_concentration = (drug_volume / total_volume) * 100.0  # Assuming 100x stock
                self._od_sensor.update_drug_concentration(vial, new_concentration)
            
            # Remove waste volume
            self._valves.open(vial)
            self._pumps[4].pump(total_volume)  # Waste pump
            
            # Add fresh media
            if media_volume > 0:
                self._pumps[1].pump(media_volume)  # Media pump
                
            # Add drug
            if drug_volume > 0:
                self._pumps[2].pump(drug_volume)  # Drug pump
                
        except Exception as e:
            self.emergency_stop()
            raise DeviceError(f"Dilution failed: {str(e)}")
            
        finally:
            self._valves.close(vial)

    def emergency_stop(self) -> None:
        """Emergency stop all device operations."""
        try:
            # Stop all moving parts
            for pump in self._pumps.values():
                pump.stop()
            self._stirrer.stop_all()
            
            # Close all valves
            self._valves.close_all()
            
        except Exception as e:
            # Log but don't raise - must try all stop operations
            print(f"Error during emergency stop: {str(e)}")

    @property
    def vial_status(self) -> Dict[int, Dict[str, float]]:
        """Get current status of all vials."""
        status = {}
        for vial in range(1, self.config.n_vials + 1):
            try:
                measurements = self.measure_vial(vial)
                status[vial] = {
                    'od': measurements.od,
                    'temperature': measurements.temperature,
                    'rpm': measurements.rpm if measurements.rpm else 0.0
                }
            except Exception as e:
                # Include error indication in status
                status[vial] = {
                    'od': -1.0,
                    'temperature': -1.0,
                    'rpm': -1.0,
                    'error': str(e)
                }
        return status

--- core/src/replifactory_core/culture.py ---
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from .parameters import VialMeasurements
from .base_device import BaseDevice

@dataclass
class CultureConfig:
    """Configuration for bacterial culture control.
    
    Attributes:
        od_threshold: OD level that triggers dilution
        growth_rate_threshold: Growth rate that triggers stress increase
        min_growth_rate: Growth rate below which rescue dilution occurs
        dilution_factor: Factor by which to dilute culture
        max_drug_concentration: Maximum allowed drug concentration
    """
    od_threshold: float = 0.3
    growth_rate_threshold: float = 0.15
    min_growth_rate: float = -0.1
    dilution_factor: float = 1.6
    max_drug_concentration: float = 100.0

class Culture:
    """Core culture control logic.
    
    Manages a single bacterial culture vial, coordinating measurements,
    growth tracking, and drug concentration adjustments.
    
    Args:
        vial: Vial number (1-7)
        device: Device interface for hardware control
        config: Culture control parameters
    """
    
    def __init__(
        self,
        vial: int,
        device: BaseDevice,
        config: CultureConfig = CultureConfig()
    ):
        self.vial = vial
        self._device = device
        self.config = config
        
        self._measurements: List[Tuple[datetime, VialMeasurements]] = []
        self._drug_concentrations: List[Tuple[datetime, float]] = []
        self._generations: List[Tuple[datetime, float]] = []
        
        # Initialize with zero drug concentration
        self._drug_concentrations.append((datetime.now(), 0.0))
        self._generations.append((datetime.now(), 0.0))

    def measure(self) -> VialMeasurements:
        """Take new measurements of the culture.
        
        Returns:
            VialMeasurements containing current culture state
            
        Raises:
            DeviceError: If measurements fail
        """
        measurements = self._device.measure_vial(self.vial)
        self._measurements.append((datetime.now(), measurements))
        return measurements

    def calculate_growth_rate(self, window_minutes: int = 30) -> Optional[float]:
        """Calculate current growth rate from recent measurements.
        
        Args:
            window_minutes: Time window to use for calculation
            
        Returns:
            Growth rate in 1/hour or None if insufficient data
        """
        if len(self._measurements) < 2:
            return None
            
        # Get measurements in window
        now = datetime.now()
        window_measurements = [
            (t, m) for t, m in self._measurements 
            if (now - t).total_seconds() <= window_minutes * 60
        ]
        
        if len(window_measurements) < 2:
            return None
            
        # Calculate growth rate from OD measurements
        t1, m1 = window_measurements[0]
        t2, m2 = window_measurements[-1]
        
        dt = (t2 - t1).total_seconds() / 3600  # Convert to hours
        if dt == 0:
            return None
            
        return (np.log(m2.od) - np.log(m1.od)) / dt

    def make_dilution(self, target_drug_concentration: Optional[float] = None) -> None:
        """Perform dilution with optional drug concentration adjustment.
        
        Args:
            target_drug_concentration: Desired final drug concentration.
                If None, maintains current concentration.
                
        Raises:
            ValueError: If target concentration exceeds maximum
            DeviceError: If dilution operation fails
        """
        if target_drug_concentration is None:
            target_drug_concentration = self._drug_concentrations[-1][1]
            
        if target_drug_concentration > self.config.max_drug_concentration:
            raise ValueError(f"Target concentration {target_drug_concentration} exceeds maximum {self.config.max_drug_concentration}")
            
        # Calculate volumes needed
        current_volume = 12.0  # TODO: Get from device config
        added_volume = current_volume * (self.config.dilution_factor - 1)
        
        # Calculate media and drug volumes to achieve target concentration
        if target_drug_concentration > 0:
            drug_volume = added_volume * (target_drug_concentration / self.config.max_drug_concentration)
            media_volume = added_volume - drug_volume
        else:
            drug_volume = 0
            media_volume = added_volume
            
        # Perform dilution
        self._device.make_dilution(self.vial, media_volume, drug_volume)
        
        # Update tracking
        now = datetime.now()
        self._drug_concentrations.append((now, target_drug_concentration))
        
        # Update generations
        prev_gens = self._generations[-1][1]
        new_gens = prev_gens + np.log2(self.config.dilution_factor)
        self._generations.append((now, new_gens))

    @property
    def current_od(self) -> Optional[float]:
        """Get most recent OD measurement."""
        if not self._measurements:
            return None
        return self._measurements[-1][1].od
        
    @property
    def current_drug_concentration(self) -> float:
        """Get current drug concentration."""
        return self._drug_concentrations[-1][1]
        
    @property
    def generations(self) -> float:
        """Get current number of generations."""
        return self._generations[-1][1]
        
    @property
    def status(self) -> Dict:
        """Get current culture status."""
        return {
            'od': self.current_od,
            'drug_concentration': self.current_drug_concentration,
            'generations': self.generations,
            'growth_rate': self.calculate_growth_rate(),
            'last_measurement': self._measurements[-1][0] if self._measurements else None
        } 

--- core/src/replifactory_core/experiment.py ---
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional
import json

from .culture import Culture, CultureConfig
from .base_device import BaseDevice, BaseDeviceConfig
from .interfaces import DeviceError
from .protocols import GrowthControlProtocol, MorbidostatProtocol, MorbidostatConfig

@dataclass
class ExperimentConfig:
    """Configuration for experiment control.
    
    Attributes:
        measurement_interval_mins: Time between measurements
        max_generations: Stop experiment after this many generations
        max_duration_hours: Stop experiment after this many hours
        culture_config: Configuration applied to all cultures
        device_config: Device configuration
    """
    measurement_interval_mins: int = 10
    max_generations: Optional[float] = None
    max_duration_hours: Optional[float] = None
    culture_config: CultureConfig = CultureConfig()
    device_config: BaseDeviceConfig = BaseDeviceConfig()

class Experiment:
    """Coordinates multiple bacterial cultures in an evolution experiment.
    
    Manages multiple cultures, scheduling measurements and dilutions
    according to the experimental protocol.
    
    Args:
        device: Device interface for hardware control
        config: Experiment parameters
        name: Optional experiment identifier
    """
    
    def __init__(
        self,
        device: BaseDevice,
        config: ExperimentConfig = ExperimentConfig(),
        name: Optional[str] = None,
        protocol: Optional[GrowthControlProtocol] = None
    ):
        self.name = name or datetime.now().strftime("%Y%m%d_%H%M%S")
        self.config = config
        self._device = device
        self._start_time = datetime.now()
        
        # Initialize protocol
        self.protocol = protocol or MorbidostatProtocol(MorbidostatConfig())
        
        # Initialize cultures
        self.cultures: Dict[int, Culture] = {}
        for vial in range(1, self.config.device_config.n_vials + 1):
            self.cultures[vial] = Culture(
                vial=vial,
                device=device,
                config=config.culture_config
            )
        
        self._status = "initialized"
        self._error: Optional[str] = None
        
    def start(self) -> None:
        """Start the experiment.
        
        Initializes all cultures and begins measurement cycle.
        
        Raises:
            DeviceError: If device initialization fails
            RuntimeError: If experiment already running
        """
        if self._status == "running":
            raise RuntimeError("Experiment already running")
            
        try:
            # Take initial measurements
            for culture in self.cultures.values():
                culture.measure()
                
            self._status = "running"
            self._start_time = datetime.now()
            self._error = None
            
        except Exception as e:
            self._status = "error"
            self._error = str(e)
            raise

    def stop(self) -> None:
        """Stop the experiment.
        
        Stops all device operations and sets experiment to stopped state.
        """
        try:
            self._device.emergency_stop()
        except DeviceError as e:
            self._error = f"Error during stop: {str(e)}"
            
        self._status = "stopped"

    def pause(self) -> None:
        """Pause the experiment.
        
        Temporarily suspends operations while maintaining state.
        """
        if self._status != "running":
            raise RuntimeError(f"Cannot pause experiment in {self._status} state")
            
        self._status = "paused"

    def resume(self) -> None:
        """Resume a paused experiment."""
        if self._status != "paused":
            raise RuntimeError(f"Cannot resume experiment in {self._status} state")
            
        self._status = "running"

    def update(self) -> None:
        """Perform one update cycle using configured protocol."""
        if self._status != "running":
            return
        
        try:
            # Update each culture using protocol
            for culture in self.cultures.values():
                self.protocol.update(culture)
                
            self._check_end_conditions()
                
        except Exception as e:
            self._status = "error"
            self._error = str(e)
            raise

    def _check_end_conditions(self) -> None:
        """Check if experiment should end based on config."""
        if self.config.max_generations:
            max_gens = max(c.generations for c in self.cultures.values())
            if max_gens >= self.config.max_generations:
                self.stop()
                
        if self.config.max_duration_hours:
            duration = (datetime.now() - self._start_time).total_seconds() / 3600
            if duration >= self.config.max_duration_hours:
                self.stop()

    @property
    def status(self) -> Dict:
        """Get current experiment status."""
        return {
            'name': self.name,
            'status': self._status,
            'error': self._error,
            'start_time': self._start_time.isoformat(),
            'duration_hours': (datetime.now() - self._start_time).total_seconds() / 3600,
            'cultures': {
                vial: culture.status 
                for vial, culture in self.cultures.items()
            }
        }

    def save_state(self, filename: str) -> None:
        """Save experiment state to file.
        
        Args:
            filename: Path to save state file
        """
        state = {
            'name': self.name,
            'config': self.config.__dict__,
            'status': self.status,
            'timestamp': datetime.now().isoformat()
        }
        
        with open(filename, 'w') as f:
            json.dump(state, f, indent=2)

    @classmethod
    def load_state(cls, filename: str, device: BaseDevice) -> 'Experiment':
        """Load experiment from saved state.
        
        Args:
            filename: Path to state file
            device: Device interface to use
            
        Returns:
            Reconstructed Experiment instance
        """
        with open(filename) as f:
            state = json.load(f)
            
        config = ExperimentConfig(**state['config'])
        exp = cls(device=device, config=config, name=state['name'])
        
        # Restore status
        exp._status = state['status']['status']
        exp._error = state['status']['error']
        exp._start_time = datetime.fromisoformat(state['status']['start_time'])
        
        return exp 

--- core/src/replifactory_core/factory.py ---
from abc import ABC, abstractmethod
from typing import Dict

from .interfaces import (
    PumpInterface,
    ValveInterface,
    StirrerInterface,
    ODSensorInterface,
    ThermometerInterface
)
from .base_device import BaseDevice, BaseDeviceConfig


class DeviceComponentFactory(ABC):
    """Abstract factory for creating device components.
    
    Provides interface for creating all device components.
    Concrete implementations create either real or simulated components.
    """
    
    @abstractmethod
    def create_pump(self, pump_number: int) -> PumpInterface:
        """Create a pump component.
        
        Args:
            pump_number: Identifier for the pump (1=media, 2=drug, 4=waste)
        """
        pass
    
    @abstractmethod
    def create_valves(self) -> ValveInterface:
        """Create valve control component."""
        pass
    
    @abstractmethod
    def create_stirrer(self) -> StirrerInterface:
        """Create stirrer control component."""
        pass
    
    @abstractmethod
    def create_od_sensor(self) -> ODSensorInterface:
        """Create OD measurement component."""
        pass
    
    @abstractmethod
    def create_thermometer(self) -> ThermometerInterface:
        """Create temperature measurement component."""
        pass


class DeviceFactory:
    """Factory for creating complete device instances.
    
    Creates and assembles all components into a working device.
    """
    
    @staticmethod
    def create_device(
        factory: DeviceComponentFactory,
        config: BaseDeviceConfig = BaseDeviceConfig()
    ) -> BaseDevice:
        """Create a complete device using specified component factory.
        
        Args:
            factory: Component factory (real or simulated)
            config: Device configuration
            
        Returns:
            Configured BaseDevice instance
        """
        # Create required pumps
        pumps: Dict[int, PumpInterface] = {
            1: factory.create_pump(1),  # Media pump
            2: factory.create_pump(2),  # Drug pump
            4: factory.create_pump(4)   # Waste pump
        }
        
        # Create other components
        valves = factory.create_valves()
        stirrer = factory.create_stirrer()
        od_sensor = factory.create_od_sensor()
        thermometer = factory.create_thermometer()
        
        # Assemble device
        return BaseDevice(
            config=config,
            pumps=pumps,
            valves=valves,
            stirrer=stirrer,    
            od_sensor=od_sensor,
            thermometer=thermometer
        )


--- core/src/replifactory_core/interfaces.py ---
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Dict, Optional, Tuple, List

from .parameters import *


class DeviceError(Exception):
    """Base exception for device-related errors."""
    pass


class StirrerSpeed(str, Enum):
    """Enumeration of valid stirrer speeds.
    
    STOPPED: Motor off
    LOW: Low speed for measurement
    HIGH: Normal operating speed
    """
    STOPPED = "stopped"
    LOW = "low"
    HIGH = "high"


class PumpInterface(ABC):
    """Interface for controlling fluid pumps in the device.
    
    Provides high-level control of pumping operations while abstracting away
    hardware details like stepper motors or peristaltic mechanisms.
    
    A pump must maintain accurate volume tracking and provide immediate
    stop capability for safety.
    
    Typical usage:
        pump.pump(5.0)  # Pump 5ml
        if pump.is_pumping:
            pump.stop()  # Emergency stop
    """
    
    @abstractmethod
    def pump(self, volume_ml: float) -> None:
        """Pump a specific volume of fluid.
        
        Args:
            volume_ml: Volume to pump in milliliters. Positive values pump forward,
                      negative values pump in reverse if supported.
        
        Raises:
            ValueError: If volume exceeds pump parameters
            DeviceError: If pump operation fails
        
        Note:
            Method should block until pumping is complete unless stopped.
        """
        pass
    
    @abstractmethod
    def stop(self) -> None:
        """Immediately stop the pump.
        
        Emergency stop that halts the pump as quickly as possible without
        regard for completing the current operation.
        
        The pumped_volume property should reflect the actual delivered volume.
        
        Raises:
            DeviceError: If pump fails to stop
        """
        pass

    @property
    @abstractmethod
    def is_pumping(self) -> bool:
        """Check if pump is currently active.
        
        Returns:
            bool: True if pump is in operation, False if idle
            
        Note: 
            Should return True from the moment pump() is called until 
            the operation completes or is stopped.
        """
        pass

    @property
    @abstractmethod
    def pumped_volume(self) -> float:
        """Get total volume pumped since last reset.
        
        Returns:
            float: Cumulative volume in milliliters, including partial volumes
                  from stopped operations
                  
        Note:
            Tracking should continue across multiple pump operations until reset.
        """
        pass


class ValveInterface(ABC):
    """Interface for controlling liquid flow valves.
    
    Controls individual solenoid valves that direct fluid flow in the device.
    Each valve has a unique number and binary open/closed state.
    
    Valves are critical for fluid routing and provide safety isolation.
    All implementations must ensure reliable state reporting and 
    fail-closed behavior.
    
    Typical usage:
        valve.open(1)   # Open valve 1
        if valve.is_open(1):
            valve.close(1)
    """
    
    @abstractmethod
    def open(self, valve_number: int) -> None:
        """Open a specific valve.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Raises:
            ValueError: If valve_number is invalid (not 1-7)
            DeviceError: If valve fails to open or verify state
            
        Note:
            Method should block until valve is fully open and verified.
        """
        pass

    @abstractmethod
    def close(self, valve_number: int) -> None:
        """Close a specific valve.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Raises:
            ValueError: If valve_number is invalid
            DeviceError: If valve fails to close or verify state
            
        Note:
            Method must ensure valve is fully closed before returning.
            Should never fail to at least attempt closure for safety.
        """
        pass

    @abstractmethod
    def is_open(self, valve_number: int) -> bool:
        """Check if specific valve is open.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Returns:
            bool: True if valve is confirmed open, False if confirmed closed
            
        Raises:
            ValueError: If valve_number is invalid
            DeviceError: If valve state cannot be determined
            
        Note:
            Must return accurate state - if state cannot be verified,
            should raise DeviceError rather than guess.
        """
        pass

    @abstractmethod
    def close_all(self) -> None:
        """Close all valves immediately.
        
        Critical safety method - must attempt to close all valves even if
        some operations fail. Should be called in any error condition.
        
        Raises:
            DeviceError: If any valve fails to close. Error should include
                        information about which valves failed.
                        
        Note:
            Should make best effort to close all valves even after errors.
        """
        pass


class StirrerInterface(ABC):
    """Interface for controlling magnetic stirrers.
    
    Manages the stirring motors that mix cultures via magnetic stir bars.
    Supports variable speeds and rotation monitoring.
    
    Speed control is critical for:
    - Proper culture mixing
    - Accurate OD measurements (requires LOW speed)
    - Prevention of vortexing (speed limits)
    
    Implementation must ensure smooth speed transitions and
    accurate RPM reporting when available.
    
    Typical usage:
        stirrer.set_speed(1, StirrerSpeed.HIGH)  # Normal operation
        rpm = stirrer.measure_rpm(1)             # Check actual speed
        stirrer.set_speed(1, StirrerSpeed.LOW)   # Prepare for measurement
    """
    
    @abstractmethod
    def set_speed(self, vial: int, speed: StirrerSpeed) -> None:
        """Set stirrer speed for a specific vial.
        
        Args:
            vial: Vial number (1-7)
            speed: Desired stirring speed setting
            
        Raises:
            ValueError: If vial number invalid or speed not in StirrerSpeed
            DeviceError: If speed cannot be set or verified
            
        Note:
            Should transition smoothly between speeds to avoid splashing.
            Must verify speed change before returning.
        """
        pass
    
    @abstractmethod
    def measure_rpm(self, vial: int) -> float:
        """Measure current RPM for specific vial.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            float: Current stirring speed in rotations per minute
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If RPM cannot be measured
            
        Note:
            May return approximate RPM if exact measurement not possible.
            Should indicate measurement quality through error bounds.
        """
        pass

    @abstractmethod
    def stop_all(self) -> None:
        """Emergency stop all stirrers.
        
        Immediately stops all stirring motors. Used in emergency situations
        or during shutdown.
        
        Raises:
            DeviceError: If any stirrer fails to stop. Should still attempt
                        to stop all stirrers even after an error.
                        
        Note:
            Must attempt to stop all stirrers regardless of errors.
            Critical safety method.
        """
        pass


class ODSensorInterface(ABC):
    """Interface for optical density measurement system.
    
    Manages laser-based optical density measurements for monitoring bacterial growth.
    Coordinates laser control and photodiode readings to produce accurate OD values.
    
    Key responsibilities:
    - Accurate OD measurements
    - Blank calibration
    - Signal quality monitoring
    - Laser safety management
    
    Implementation must ensure:
    - Laser safety interlocks
    - Proper measurement timing
    - Signal stability checking
    - Background light compensation
    
    Typical usage:
        od, signal = sensor.measure_od(1)  # Get current OD
        blank = sensor.measure_blank(1)    # Calibration measurement
    """
    
    @abstractmethod
    def measure_od(self, vial: int, parameters: Optional[ODParameters] = None) -> Tuple[float, float]:
        """Measure optical density for specific vial.
        
        Performs a complete OD measurement cycle:
        1. Set stirrer to measurement speed
        2. Turn on laser
        3. Take photodiode reading
        4. Turn off laser
        5. Restore stirrer speed
        
        Args:
            vial: Vial number (1-7)
            parameters: Optional measurement parameters. Uses defaults if None.
            
        Returns:
            Tuple[float, float]: (od_value, signal_strength)
                od_value: Calculated optical density (relative to blank)
                signal_strength: Raw photodiode signal in millivolts
                
        Raises:
            ValueError: If vial number invalid
            DeviceError: If measurement fails (laser, photodiode, or signal quality)
            
        Note:
            Returns both OD and raw signal to allow signal quality assessment.
            Should verify signal stability before returning.
        """
        pass

    @abstractmethod
    def measure_blank(self, vial: int) -> float:
        """Measure blank/reference value for calibration.
        
        Takes reference measurement of clear media for OD calculation baseline.
        Must be called on each vial before experiment starts.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            float: Blank reading in millivolts
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If measurement fails or signal unstable
            
        Note:
            Should take multiple readings and verify stability.
            Critical for accurate OD measurements.
        """
        pass


class ThermometerInterface(ABC):
    """Interface for temperature monitoring system.
    
    Manages temperature sensors for both culture vials and control board.
    Temperature monitoring is critical for:
    - Culture growth conditions
    - Hardware protection
    - Safety cutoffs
    
    Implementation must provide reliable temperature data and
    proper error handling for sensor failures.
    
    Typical usage:
        temps = thermometer.measure_temperature()
        vial_temp = temps['vials']
        board_temp = temps['board']
    """
    
    @abstractmethod
    def measure_temperature(self) -> Dict[str, float]:
        """Measure all system temperatures.
        
        Returns:
            Dict[str, float]: Temperature readings in Celsius
                'vials': Average temperature of vial array
                'board': Control board temperature
                
        Raises:
            DeviceError: If temperature measurements fail or are out of range
            
        Note:
            Should include validity checks on temperature values.
            Must handle partial sensor failures gracefully.
        """
        pass


class ExperimentDeviceInterface(ABC):
    """High-level interface for experiment control.
    
    Provides experiment-focused operations that coordinate multiple device
    components. This is the primary interface used by experiment control logic.
    
    Responsible for:
    - Measurement coordination
    - Dilution operations
    - Status monitoring
    - Emergency handling
    
    Implementation must ensure:
    - Operation atomicity
    - Error recovery
    - Data consistency
    - Safe state management
    
    Typical usage:
        measurements = device.measure_vial(1)
        device.make_dilution(1, media_ml=5.0, drug_ml=0.5)
        status = device.vial_status
    """
    
    @abstractmethod
    def measure_vial(self, vial: int) -> VialMeasurements:
        """Get all measurements for a specific vial.
        
        Performs a complete measurement cycle:
        1. Temperature reading
        2. RPM measurement if available
        3. OD measurement
        4. Growth rate calculation if possible
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            VialMeasurements: Combined measurements from vial
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If critical measurements fail
            
        Note:
            Should complete all possible measurements even if some fail.
            Critical measurements (OD) failure causes error.
        """
        pass
    
    @abstractmethod
    def make_dilution(self, vial: int, media_volume: float, drug_volume: float) -> None:
        """Perform dilution operation on specific vial.
        
        Executes complete dilution sequence:
        1. Verify volumes and vial state
        2. Remove waste volume
        3. Add fresh media
        4. Add drug solution
        5. Verify operation completion
        
        Args:
            vial: Vial number (1-7)
            media_volume: Volume of fresh media to add in ml
            drug_volume: Volume of drug solution to add in ml
            
        Raises:
            ValueError: If vial number or volumes invalid
            DeviceError: If dilution operation fails
            
        Note:
            Operation must be atomic - should revert to safe state on error.
            Must verify all steps complete successfully.
        """
        pass

    @abstractmethod
    def emergency_stop(self) -> None:
        """Emergency stop all device operations.
        
        Immediately stops all device components and sets system to safe state:
        1. Stop all pumps
        2. Close all valves
        3. Stop all stirrers
        4. Turn off all lasers
        5. Set status LEDs to error state
        
        Should be called in response to:
        - Critical errors
        - Safety interlock triggers
        - User emergency stop
        - Power issues
        
        Note:
            Most critical safety method - must be extremely reliable.
            Should attempt all steps even if some fail.
            Must log all actions and failures.
        """
        pass

    @property
    @abstractmethod
    def vial_status(self) -> Dict[int, Dict[str, float]]:
        """Get current status of all vials.
        
        Provides snapshot of system state including:
        - OD readings
        - Temperatures
        - Stirrer speeds
        - Growth rates
        
        Returns:
            Dict[int, Dict[str, float]]: Status data
                Keys: vial numbers (1-7)
                Values: dict with measurement values
                    'od': Current optical density
                    'temperature': Current temperature
                    'rpm': Current stirrer speed if available
                    'growth_rate': Current growth rate if available
        
        Note:
            Should return best available data even if some readings fail.
            Must indicate missing/failed measurements appropriately.
        """
        pass

--- core/src/replifactory_core/parameters.py ---
from dataclasses import dataclass
from enum import Enum
from typing import Optional

@dataclass
class VialMeasurements:
    """Container for measurements from a single vial.
    
    Contains all measurements that can be taken from a vial at a single point in time.
    Used to group measurements and handle missing/failed readings gracefully.
    
    Attributes:
        od: Optical density measurement
        temperature: Temperature in Celsius
        rpm: Stirrer speed in rotations per minute (None if not available)
        growth_rate: Calculated growth rate in 1/hour (None if not enough data)
        signal_mv: Raw photodiode signal in millivolts (None if not relevant)
        blank_mv: Calibration blank reading in millivolts (None if not set)
        
    Note:
        - Only od and temperature are required
        - Other fields may be None if measurement failed or isn't available
        - signal_mv and blank_mv are for OD measurement diagnostics
    """
    od: float
    temperature: float
    rpm: Optional[float] = None
    growth_rate: Optional[float] = None 
    signal_mv: Optional[float] = None
    blank_mv: Optional[float] = None

    def __post_init__(self):
        """Validate measurements after initialization."""
        if self.od < 0:
            raise ValueError("OD cannot be negative")
        if self.temperature < 0 or self.temperature > 50:
            raise ValueError("Temperature out of valid range (0-50°C)")
        if self.rpm is not None and self.rpm < 0:
            raise ValueError("RPM cannot be negative")
        if self.signal_mv is not None and self.signal_mv < 0:
            raise ValueError("Signal voltage cannot be negative")
        if self.blank_mv is not None and self.blank_mv < 0:
            raise ValueError("Blank voltage cannot be negative")

@dataclass
class PumpParameters:
    """Parameters defining pump operational characteristics.
    
    Attributes:
        max_volume_ml: Maximum volume in ml that can be pumped in one operation
        min_volume_ml: Minimum volume in ml that can be reliably pumped
        flow_rate_mlps: Flow rate in milliliters per second
    
    Note:
        These parameters are used for both real and simulated pumps to ensure
        consistent behavior across implementations.
    """
    max_volume_ml: float 
    min_volume_ml: float
    flow_rate_mlps: float  


@dataclass
class ODParameters:
    """Parameters for optical density measurements.
    
    These settings control the sensitivity and accuracy of OD readings.
    
    Attributes:
        gain: Amplification factor for photodiode signal (1, 2, 4, or 8)
            Higher gain for low OD samples, lower for high OD
        bitrate: ADC resolution in bits (12, 14, 16, or 18)
            Higher bitrate gives better precision but slower readings
        continuous_conversion: If True, ADC runs continuously
        samples_to_average: Number of samples to take and average
    """
    gain: int = 8
    bitrate: int = 16
    continuous_conversion: bool = False
    samples_to_average: int = 3


@dataclass
class LaserParameters:
    """Parameters for laser operation.
    
    Controls laser behavior during measurements.
    
    Attributes:
        warmup_time_ms: Time to wait after laser on before reading
        measurement_time_ms: Duration of measurement
        cooldown_time_ms: Time to wait between measurements
    """
    warmup_time_ms: int = 20
    measurement_time_ms: int = 100
    cooldown_time_ms: int = 50


@dataclass
class StirrerParameters:
    """Parameters for stirrer operation.
    
    Defines stirring behavior for different modes.
    
    Attributes:
        high_speed_duty_cycle: PWM duty cycle for normal operation (0-1)
        low_speed_duty_cycle: PWM duty cycle for measurement (0-1)
        acceleration_time_ms: Time to reach target speed
    """
    high_speed_duty_cycle: float = 0.8
    low_speed_duty_cycle: float = 0.3
    acceleration_time_ms: int = 100


@dataclass
class MeasurementParameters:
    """Combined parameters for all measurement operations.
    
    Collects all measurement-related parameters in one place.
    
    Attributes:
        od: Optical density measurement parameters
        laser: Laser operation parameters
        stirrer: Stirrer behavior parameters
        wait_for_steady_state: If True, verify readings are stable
        max_retries: Number of measurement retries on error
    """
    od: ODParameters = ODParameters()
    laser: LaserParameters = LaserParameters()
    stirrer: StirrerParameters = StirrerParameters()
    wait_for_steady_state: bool = True
    max_retries: int = 3

--- core/src/replifactory_core/protocols.py ---
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional, Dict, List
from datetime import datetime
import numpy as np

from .culture import Culture
from .parameters import VialMeasurements


@dataclass
class ProtocolConfig:
    """Base configuration for growth control protocols."""
    pass


@dataclass
class MorbidostatConfig(ProtocolConfig):
    """Configuration for morbidostat control protocol.
    
    Attributes:
        od_threshold: OD level that triggers dilution
        target_growth_rate: Desired growth rate to maintain
        growth_rate_tolerance: Acceptable deviation from target
        min_growth_rate: Growth rate below which rescue dilution occurs
        max_drug_concentration: Maximum allowed drug concentration
        drug_concentration_step: Relative increase in drug concentration
        dilution_factor: Factor by which to dilute culture
        measurement_window_mins: Time window for growth rate calculation
    """
    od_threshold: float = 0.3
    target_growth_rate: float = 0.15  # hr^-1
    growth_rate_tolerance: float = 0.05
    min_growth_rate: float = -0.1
    max_drug_concentration: float = 100.0
    drug_concentration_step: float = 1.5
    dilution_factor: float = 1.6
    measurement_window_mins: int = 30


class GrowthControlProtocol(ABC):
    """Base class for growth control protocols.
    
    Defines interface for implementing different control strategies.
    """
    
    @abstractmethod
    def update(self, culture: Culture) -> Optional[Dict]:
        """Update control protocol for a culture.
        
        Args:
            culture: Culture to update
            
        Returns:
            Optional[Dict]: Control actions taken, if any
        """
        pass
    
    @abstractmethod
    def get_status(self) -> Dict:
        """Get current protocol status."""
        pass


class MorbidostatProtocol(GrowthControlProtocol):
    """Morbidostat growth control protocol.
    
    Implements feedback control to maintain constant growth rate by
    adjusting drug concentration. Core logic:
    
    1. Dilute when OD exceeds threshold
    2. If growth rate too high: increase drug concentration
    3. If growth rate too low: decrease drug concentration
    4. If growth severely inhibited: perform rescue dilution
    
    Args:
        config: Protocol configuration parameters
    """
    
    def __init__(self, config: MorbidostatConfig = MorbidostatConfig()):
        self.config = config
        self._history: List[Dict] = []
        
    def update(self, culture: Culture) -> Optional[Dict]:
        """Update morbidostat control for a culture.
        
        Implements core morbidostat logic:
        1. Calculate current growth rate
        2. Determine if dilution needed
        3. Adjust drug concentration based on growth rate
        
        Args:
            culture: Culture to update
            
        Returns:
            Dict with control actions if any were taken
        """
        # Get current measurements
        measurements = culture.measure()
        growth_rate = culture.calculate_growth_rate(
            window_minutes=self.config.measurement_window_mins
        )
        
        # Initialize response
        response = {
            'timestamp': datetime.now(),
            'od': measurements.od,
            'growth_rate': growth_rate,
            'drug_concentration': culture.current_drug_concentration,
            'action': None
        }
        
        # Check if growth rate could be calculated
        if growth_rate is None:
            self._history.append(response)
            return response
            
        # Determine control action
        action = self._determine_control_action(measurements, growth_rate)
        
        # Execute control action
        if action:
            response['action'] = action
            self._execute_control_action(culture, action)
            
        self._history.append(response)
        return response
    
    def _determine_control_action(
        self, 
        measurements: VialMeasurements, 
        growth_rate: float
    ) -> Optional[str]:
        """Determine appropriate control action based on measurements.
        
        Args:
            measurements: Current culture measurements
            growth_rate: Calculated growth rate
            
        Returns:
            String indicating control action or None if no action needed
        """
        # Check for severely inhibited growth
        if growth_rate < self.config.min_growth_rate:
            return 'rescue_dilution'
            
        # Check if OD threshold exceeded
        if measurements.od < self.config.od_threshold:
            return None
            
        # Determine drug adjustment based on growth rate
        growth_error = growth_rate - self.config.target_growth_rate
        
        if abs(growth_error) <= self.config.growth_rate_tolerance:
            return 'maintain'
        elif growth_error > 0:
            return 'increase_drug'
        else:
            return 'decrease_drug'
    
    def _execute_control_action(self, culture: Culture, action: str) -> None:
        """Execute determined control action.
        
        Args:
            culture: Culture to control
            action: Control action to execute
        """
        current_conc = culture.current_drug_concentration
        
        if action == 'rescue_dilution':
            # Perform dilution with reduced drug concentration
            new_conc = max(0, current_conc / self.config.drug_concentration_step)
            culture.make_dilution(target_drug_concentration=new_conc)
            
        elif action == 'maintain':
            # Maintain current drug concentration
            culture.make_dilution()
            
        elif action == 'increase_drug':
            # Increase drug concentration
            new_conc = min(
                self.config.max_drug_concentration,
                current_conc * self.config.drug_concentration_step
            )
            culture.make_dilution(target_drug_concentration=new_conc)
            
        elif action == 'decrease_drug':
            # Decrease drug concentration
            new_conc = current_conc / self.config.drug_concentration_step
            culture.make_dilution(target_drug_concentration=new_conc)
    
    def get_status(self) -> Dict:
        """Get current protocol status.
        
        Returns:
            Dict containing:
            - Configuration parameters
            - Control history
            - Current state
        """
        return {
            'config': self.config.__dict__,
            'history': self._history,
            'latest': self._history[-1] if self._history else None
        }


class TurbidostatProtocol(GrowthControlProtocol):
    """Turbidostat growth control protocol.
    
    Maintains constant cell density by diluting when OD exceeds threshold.
    No drug concentration adjustment.
    """
    # TODO: Implement turbidostat logic
    pass


class ChemostatProtocol(GrowthControlProtocol):
    """Chemostat growth control protocol.
    
    Maintains constant dilution rate regardless of growth.
    """
    # TODO: Implement chemostat logic
    pass 

--- core/src/replifactory_core/types.py ---


--- core/tests/.gitkeep ---


--- docs/developer-guide/.gitkeep ---


--- docs/index.md ---


--- docs/user-guide/.gitkeep ---


--- hardware/pyproject.toml ---


--- hardware/tests/.gitkeep ---


--- mkdocs.yml ---


--- nx.json ---


--- server/pyproject.toml ---


--- server/src/replifactory_server/.gitkeep ---


--- server/tests/.gitkeep ---


--- simulation/examples/quick_start.py ---
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.experiment import ExperimentConfig
from replifactory_simulation.growth_model import GrowthModelParameters
import time
from datetime import datetime

def format_time(hours):
    """Format time in hours nicely"""
    return f"{int(hours)}h {int((hours % 1) * 60)}m"

def main():
    # Create a longer experiment configuration
    exp_config = ExperimentConfig(
        measurement_interval_mins=10,    # Measure every 10 minutes
        max_duration_hours=24           # Run for 24 hours
    )
    
    # Configure realistic growth parameters
    model_params = GrowthModelParameters(
        doubling_time_mins=30,          # Fast growing bacteria
        initial_od=0.1,                 # Starting OD
        carrying_capacity=1.0,          # Maximum OD
        ic50_initial=10.0              # Initial drug resistance
    )
    
    # Create simulation with 100x speed acceleration (24h will take ~14 min real time)
    runner = SimulationRunner(
        config=exp_config,
        model_params=model_params,
        time_acceleration=100.0
    )
    
    print(f"Starting simulation at {datetime.now().strftime('%H:%M:%S')}")
    print("Running 24-hour experiment at 100x speed")
    print("Press Ctrl+C to stop early\n")
    
    runner.start()
    
    try:
        last_print = time.time()
        while runner.experiment._status == "running":
            # Get current status
            status = runner.experiment.status
            current_time = status['duration_hours']
            
            # Print update every 5 seconds
            if time.time() - last_print >= 5.0:
                print(f"\nSimulation Time: {format_time(current_time)} / 24h")
                print("Culture Status:")
                for vial, data in status['cultures'].items():
                    print(f"  Vial {vial}:")
                    print(f"    OD: {data['od']:.3f}")
                    if 'drug_concentration' in data:
                        print(f"    Drug: {data['drug_concentration']:.1f}")
                    if 'growth_rate' in data:
                        print(f"    Growth Rate: {data['growth_rate']:.3f}/hr")
                last_print = time.time()
            
            # Don't burn CPU
            time.sleep(0.1)
            
    except KeyboardInterrupt:
        print("\nStopping simulation early...")
    finally:
        runner.stop()
        
        # Show results
        print("\nGenerating plots...")
        runner.logger.plot_growth_curves()
        print(f"\nResults saved in: simulation_logs/{runner.logger.experiment_id}/")
        
        # Load and show final statistics
        df = runner.logger.load_measurements()
        if not df.empty:
            print("\nExperiment Summary:")
            print(f"Duration: {format_time(df['timestamp'].max().hour)}")
            print(f"Total measurements: {len(df)}")
            print("\nFinal ODs:")
            final_ods = df.groupby('vial').last()['od']
            print(final_ods)
        else:
            print("\nNo measurements recorded!")

if __name__ == "__main__":
    main() 

--- simulation/examples/run_simulation.py ---
from replifactory_simulation.runner import SimulationRunner
from replifactory_core.experiment import ExperimentConfig
from replifactory_simulation.growth_model import GrowthModelParameters

def main():
    # Configure simulation
    exp_config = ExperimentConfig(
        measurement_interval_mins=10,
        max_duration_hours=24
    )
    
    model_params = GrowthModelParameters(
        doubling_time_mins=30,
        ic50_initial=5.0
    )
    
    # Create and start simulation
    runner = SimulationRunner(
        config=exp_config,
        model_params=model_params,
        time_acceleration=60  # 60x speed
    )
    
    try:
        runner.start()
        
        # Wait for simulation to complete
        while runner.experiment._status == "running":
            status = runner.experiment.status
            print(f"Time: {status['duration_hours']:.1f}h")
            print("Culture ODs:", {
                vial: f"{data['od']:.3f}"
                for vial, data in status['cultures'].items()
            })
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("Stopping simulation...")
    finally:
        runner.stop()
        # Plot results
        runner.logger.plot_growth_curves()
        
        # Show summary
        df = runner.logger.load_measurements()
        print("\nExperiment Summary:")
        if not df.empty:
            duration = df['timestamp'].max() - df['timestamp'].min()
            print(f"Duration: {duration}")
            print(f"Total measurements: {len(df)}")
            print("\nFinal ODs:")
            final_ods = df.groupby('vial').last()['od']
            print(final_ods)
        else:
            print("No measurements recorded!")
            print("Check simulation logs for errors.")

if __name__ == "__main__":
    main() 

--- simulation/pyproject.toml ---


--- simulation/src/replifactory_simulation/.gitkeep ---


--- simulation/src/replifactory_simulation/__init__.py ---


--- simulation/src/replifactory_simulation/devices.py ---
from dataclasses import dataclass
import time
from typing import Dict, Optional, Tuple

import threading
import numpy as np

from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface, StirrerSpeed,
    DeviceError
)
from replifactory_core.parameters import ODParameters

from .growth_model import GrowthModel, GrowthModelParameters


@dataclass
class SimulatedPump(PumpInterface):    
    pump_number: int
    flow_rate_mlps: float = 1.0
    
    def __post_init__(self):
        self._is_pumping = False
        self._volume_pumped = 0.0
        self._lock = threading.Lock()  # Lock for thread safety
    
    def pump(self, volume_ml: float) -> None:
        if not self._lock.acquire(blocking=False):  # Try to acquire lock
            raise DeviceError("Pump already in use")
        
        try:
            self._is_pumping = True
            duration = abs(volume_ml) / self.flow_rate_mlps
            time.sleep(duration)  # Simulate pumping time
            self._volume_pumped += volume_ml
        finally:
            self._is_pumping = False
            self._lock.release()
    
    def stop(self) -> None:
        self._is_pumping = False
    
    @property
    def is_pumping(self) -> bool:
        return self._is_pumping
    
    @property
    def pumped_volume(self) -> float:
        return self._volume_pumped


class SimulatedValves(ValveInterface):
    def __init__(self):
        self._states = {i: False for i in range(1, 8)}  # False = closed
    
    def open(self, valve_number: int) -> None:
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        self._states[valve_number] = True
        time.sleep(0.1)  # Simulate valve movement
    
    def close(self, valve_number: int) -> None:
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        self._states[valve_number] = False
        time.sleep(0.1)  # Simulate valve movement
    
    def is_open(self, valve_number: int) -> bool:
        if not 1 <= valve_number <= 7:
            raise ValueError(f"Invalid valve number: {valve_number}")
        return self._states[valve_number]
    
    def close_all(self) -> None:
        for v in range(1, 8):
            self._states[v] = False


class SimulatedStirrer(StirrerInterface):
    def __init__(self):
        self._speeds = {i: StirrerSpeed.STOPPED for i in range(1, 8)}
        self._rpm_map = {
            StirrerSpeed.STOPPED: 0.0,
            StirrerSpeed.LOW: 400.0,
            StirrerSpeed.HIGH: 1200.0
        }
    
    def set_speed(self, vial: int, speed: StirrerSpeed) -> None:
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
        self._speeds[vial] = speed
        time.sleep(0.2)  # Simulate speed change
    
    def measure_rpm(self, vial: int) -> float:
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
        base_rpm = self._rpm_map[self._speeds[vial]]
        # Add some noise
        return base_rpm * (1 + 0.05 * (2 * np.random.random() - 1))
    
    def stop_all(self) -> None:
        for v in range(1, 8):
            self._speeds[v] = StirrerSpeed.STOPPED


class SimulatedODSensor(ODSensorInterface):
    """Simulates bacterial growth and OD measurements."""
    
    def __init__(self, model_params: Optional[GrowthModelParameters] = None):
        # Initialize growth models for each vial
        self._growth_models = {
            i: GrowthModel(parameters=model_params)
            for i in range(1, 8)
        }
        
        # Blank values for each vial
        self.blank_values = {i: 1000.0 for i in range(1, 8)}  # mV
        
    def measure_blank(self, vial: int) -> float:
        """Measure blank (empty vial) signal."""
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Add some noise to the blank measurement
        blank = self.blank_values[vial] * (1 + 0.005 * np.random.randn())
        time.sleep(0.1)  # Simulate measurement time
        return blank
        
    def measure_od(self, vial: int, parameters: Optional[ODParameters] = None) -> Tuple[float, float]:
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Get current OD from growth model
        model = self._growth_models[vial]
        
        # Add measurement noise
        measured_od = model.od * (1 + 0.02 * np.random.randn())
        signal = 1000 * np.exp(-measured_od) * (1 + 0.01 * np.random.randn())
        
        time.sleep(0.1)  # Simulate measurement time
        return measured_od, signal
        
    def update_drug_concentration(self, vial: int, concentration: float):
        """Update drug concentration after dilution."""
        if not 1 <= vial <= 7:
            raise ValueError(f"Invalid vial number: {vial}")
            
        model = self._growth_models[vial]
        model.drug_concentration = concentration


class SimulatedThermometer(ThermometerInterface):
    def __init__(self):
        self._temp_setpoint = 37.0
        
    def measure_temperature(self) -> Dict[str, float]:
        # Add noise to temperature
        vial_temp = self._temp_setpoint + 0.5 * (2 * np.random.random() - 1)
        board_temp = 35.0 + 0.2 * (2 * np.random.random() - 1)
        
        time.sleep(0.1)  # Simulate measurement
        return {
            'vials': vial_temp,
            'board': board_temp
        }

--- simulation/src/replifactory_simulation/factory.py ---
from typing import Dict, Optional

from replifactory_core.factory import DeviceComponentFactory
from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface
)
from replifactory_core.base_device import BaseDevice, BaseDeviceConfig

from .devices import (
    SimulatedPump, SimulatedValves, SimulatedStirrer,
    SimulatedODSensor, SimulatedThermometer
)
from .growth_model import GrowthModelParameters

class SimulationFactory(DeviceComponentFactory):
    """Factory for creating simulated device components."""
    
    def create_device(
        self, 
        config: BaseDeviceConfig,
        model_params: Optional[GrowthModelParameters] = None
    ) -> BaseDevice:
        """Create complete simulated device."""
        pumps = {
            1: self.create_pump(1),  # Media
            2: self.create_pump(2),  # Drug
            4: self.create_pump(4)   # Waste
        }
        
        return BaseDevice(
            config=config,
            pumps=pumps,
            valves=self.create_valves(),
            stirrer=self.create_stirrer(),
            od_sensor=self.create_od_sensor(model_params),
            thermometer=self.create_thermometer()
        )
    
    def create_pump(self, pump_number: int) -> PumpInterface:
        """Create simulated pump."""
        return SimulatedPump(pump_number=pump_number)
    
    def create_valves(self) -> ValveInterface:
        """Create simulated valve control."""
        return SimulatedValves()
    
    def create_stirrer(self) -> StirrerInterface:
        """Create simulated stirrer control."""
        return SimulatedStirrer()
    
    def create_od_sensor(self, model_params: Optional[GrowthModelParameters] = None) -> ODSensorInterface:
        """Create simulated OD sensor."""
        return SimulatedODSensor(model_params)
    
    def create_thermometer(self) -> ThermometerInterface:
        """Create simulated thermometer."""
        return SimulatedThermometer() 

--- simulation/src/replifactory_simulation/growth_model.py ---
from dataclasses import dataclass
import numpy as np
from typing import Optional


@dataclass
class GrowthModelParameters:
    """Parameters controlling bacterial growth simulation.
    
    Attributes:
        initial_od: Starting optical density
        doubling_time_mins: Time for population to double without drug
        carrying_capacity: Maximum OD the culture can reach
        mu_min: Minimum growth rate (can be negative for death)
        ic50_initial: Initial drug concentration causing 50% growth inhibition
        ic10_ic50_ratio: Ratio of IC10 to IC50 (controls dose response curve)
        adaptation_rate_max: Maximum rate of drug adaptation
        adaptation_rate_ic10_ic50_ratio: Controls adaptation vs. drug concentration
    """
    initial_od: float = 0.05
    doubling_time_mins: float = 20.0
    carrying_capacity: float = 0.9
    mu_min: float = -0.1
    ic50_initial: float = 5.0
    ic10_ic50_ratio: float = 0.5
    adaptation_rate_max: float = 0.08
    adaptation_rate_ic10_ic50_ratio: float = 0.8


class GrowthModel:
    """Simulates bacterial growth with drug adaptation.
    
    Implements core growth model including:
    - Basic bacterial growth
    - Drug response
    - Evolution of drug resistance
    - Population carrying capacity
    
    The model tracks:
    - Current population (OD)
    - Drug concentration
    - Drug resistance (IC50)
    - Growth rate
    """
    
    def __init__(self, parameters: Optional[GrowthModelParameters] = None):
        """Initialize growth model.
        
        Args:
            parameters: Growth model parameters. Uses defaults if None.
        """
        self.params = parameters or GrowthModelParameters()
        
        # Calculate base growth rate from doubling time
        self.mu_max = np.log(2) / (self.params.doubling_time_mins / 60)
        
        # Initialize state
        self.od = self.params.initial_od
        self.drug_concentration = 0.0
        self.ic50 = self.params.ic50_initial
        self._growth_rate = None
        
    def growth_rate(self, drug_conc: float, od: float) -> float:
        """Calculate growth rate under given conditions.
        
        Combines effects of:
        - Base growth rate
        - Drug inhibition
        - Carrying capacity
        
        Args:
            drug_conc: Current drug concentration
            od: Current optical density
            
        Returns:
            Growth rate in 1/hour
        """
        # Calculate drug effect using 4-parameter logistic
        ic10 = self.ic50 * self.params.ic10_ic50_ratio
        k = np.log(9) / (self.ic50 - ic10)
        drug_effect = self.params.mu_min + (
            self.mu_max / (1 + np.exp(-k * (self.ic50 - drug_conc)))
        )
        
        # Apply carrying capacity limitation
        capacity_effect = (1 - od / self.params.carrying_capacity)
        
        return drug_effect * capacity_effect
    
    def adaptation_rate(self, drug_conc: float) -> float:
        """Calculate rate of drug resistance adaptation.
        
        Models evolution of drug resistance using modified Gaussian curve.
        
        Args:
            drug_conc: Current drug concentration
            
        Returns:
            Adaptation rate in 1/hour
        """
        ic10 = self.ic50 * self.params.ic10_ic50_ratio
        k_adapt = -np.log(self.params.adaptation_rate_ic10_ic50_ratio) / ((ic10 - self.ic50) ** 2)
        return self.params.adaptation_rate_max * np.exp(-k_adapt * ((drug_conc - self.ic50) ** 2))
    
    def update(self, timestep_mins: float, new_drug_conc: Optional[float] = None):
        """Update model state for one timestep.
        
        Args:
            timestep_mins: Time step in minutes
            new_drug_conc: New drug concentration if changed, else uses current
            
        Updates internal state:
        - OD based on growth
        - IC50 based on adaptation
        - Stores current growth rate
        """
        if new_drug_conc is not None:
            self.drug_concentration = new_drug_conc
            
        # Calculate current growth rate
        self._growth_rate = self.growth_rate(self.drug_concentration, self.od)
        
        # Update population
        hours = timestep_mins / 60
        self.od *= np.exp(self._growth_rate * hours)
        
        # Update drug resistance
        adapt_rate = self.adaptation_rate(self.drug_concentration)
        self.ic50 *= np.exp(adapt_rate * hours)
    
    def dilute(self, dilution_factor: float, new_drug_conc: Optional[float] = None):
        """Perform dilution operation.
        
        Args:
            dilution_factor: Factor by which culture is diluted
            new_drug_conc: New drug concentration after dilution
        """
        self.od /= dilution_factor
        if new_drug_conc is not None:
            self.drug_concentration = new_drug_conc
            
    @property
    def growth_rate_current(self) -> float:
        """Get most recently calculated growth rate."""
        return self._growth_rate if self._growth_rate is not None else 0.0

--- simulation/src/replifactory_simulation/logging.py ---
from dataclasses import dataclass, asdict
from datetime import datetime
import json
import os
from pathlib import Path
from typing import Dict, List, Optional, Union
import pandas as pd
import numpy as np

@dataclass
class MeasurementLog:
    """Single measurement data point.
    
    Attributes:
        timestamp: Time of measurement
        vial: Vial number
        od: Optical density
        temperature: Temperature in Celsius
        drug_concentration: Current drug concentration
        growth_rate: Calculated growth rate if available
        action: Control action taken if any
    """
    timestamp: datetime
    vial: int
    od: float
    temperature: float
    drug_concentration: float
    growth_rate: Optional[float] = None
    action: Optional[str] = None

@dataclass
class ExperimentLog:
    """Complete experiment log.
    
    Attributes:
        experiment_id: Unique experiment identifier
        start_time: Experiment start time
        config: Experiment configuration
        measurements: List of all measurements
        events: List of significant events
    """
    experiment_id: str
    start_time: datetime
    config: Dict
    measurements: List[MeasurementLog] = None
    events: List[Dict] = None
    
    def __post_init__(self):
        self.measurements = self.measurements or []
        self.events = self.events or []


class SimulationLogger:
    """Handles data logging for simulated experiments.
    
    Logs measurements, events, and configuration to both:
    - CSV files for easy analysis
    - JSON for complete state preservation
    
    Args:
        output_dir: Directory for log files
        experiment_id: Unique experiment identifier
    """
    
    def __init__(self, output_dir: Union[str, Path], experiment_id: Optional[str] = None):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        self.experiment_id = experiment_id or datetime.now().strftime("%Y%m%d_%H%M%S")
        self.experiment_dir = self.output_dir / self.experiment_id
        self.experiment_dir.mkdir(exist_ok=True)
        
        self.log = ExperimentLog(
            experiment_id=self.experiment_id,
            start_time=datetime.now(),
            config={}
        )
        
    def log_config(self, config: Dict):
        """Log experiment configuration."""
        self.log.config = config
        self._save_json()
        
    def log_measurement(
        self,
        vial: int,
        od: float,
        temperature: float,
        drug_concentration: float,
        growth_rate: Optional[float] = None,
        action: Optional[str] = None
    ):
        """Log single measurement."""
        measurement = MeasurementLog(
            timestamp=datetime.now(),
            vial=vial,
            od=od,
            temperature=temperature,
            drug_concentration=drug_concentration,
            growth_rate=growth_rate,
            action=action
        )
        self.log.measurements.append(measurement)
        self._append_csv(measurement)
        
    def log_event(self, event_type: str, details: Dict):
        """Log significant event."""
        event = {
            'timestamp': datetime.now().isoformat(),
            'type': event_type,
            **details
        }
        self.log.events.append(event)
        self._save_json()
        
    def _append_csv(self, measurement: MeasurementLog):
        """Append measurement to CSV file."""
        csv_path = self.experiment_dir / 'measurements.csv'
        
        # Convert to dict for pandas
        data = asdict(measurement)
        data['timestamp'] = data['timestamp'].isoformat()
        
        # Create or append to CSV
        df = pd.DataFrame([data])
        if not csv_path.exists():
            df.to_csv(csv_path, index=False)
        else:
            df.to_csv(csv_path, mode='a', header=False, index=False)
            
    def _save_json(self):
        """Save complete log to JSON."""
        json_path = self.experiment_dir / 'experiment.json'
        
        # Convert to serializable format
        data = asdict(self.log)
        data['start_time'] = data['start_time'].isoformat()
        
        for m in data['measurements']:
            m['timestamp'] = m['timestamp'].isoformat()
            
        with open(json_path, 'w') as f:
            json.dump(data, f, indent=2)
            
    def load_measurements(self) -> pd.DataFrame:
        """Load measurements as pandas DataFrame."""
        csv_path = self.experiment_dir / 'measurements.csv'
        if not csv_path.exists():
            return pd.DataFrame()
            
        df = pd.read_csv(csv_path)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        return df
    
    def plot_growth_curves(self):
        """Plot OD and drug concentration over time."""
        import matplotlib.pyplot as plt
        
        df = self.load_measurements()
        if df.empty:
            return
            
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)
        
        # Plot OD
        for vial in df['vial'].unique():
            vial_data = df[df['vial'] == vial]
            ax1.plot(vial_data['timestamp'], vial_data['od'], 
                    label=f'Vial {vial}')
        ax1.set_ylabel('OD')
        ax1.set_yscale('log')
        ax1.legend()
        ax1.grid(True)
        
        # Plot drug concentration
        for vial in df['vial'].unique():
            vial_data = df[df['vial'] == vial]
            ax2.plot(vial_data['timestamp'], vial_data['drug_concentration'],
                    label=f'Vial {vial}')
        ax2.set_ylabel('Drug Concentration')
        ax2.set_xlabel('Time')
        ax2.grid(True)
        
        plt.tight_layout()
        plt.savefig(self.experiment_dir / 'growth_curves.png')
        plt.close() 

--- simulation/src/replifactory_simulation/runner.py ---
import time
from threading import Thread, Event
from typing import Optional

from replifactory_core.experiment import Experiment, ExperimentConfig
from replifactory_core.protocols import MorbidostatProtocol, MorbidostatConfig
from replifactory_core.base_device import BaseDeviceConfig

from .factory import SimulationFactory
from .growth_model import GrowthModelParameters
from .logging import SimulationLogger

class SimulationRunner:
    """Runs complete experiment simulation.
    
    Coordinates:
    - Device simulation
    - Growth model updates
    - Protocol execution
    - Time management
    
    Args:
        config: Experiment configuration
        model_params: Growth model parameters
        time_acceleration: Factor to speed up simulation time
    """
    
    def __init__(
        self,
        config: Optional[ExperimentConfig] = None,
        model_params: Optional[GrowthModelParameters] = None,
        time_acceleration: float = 1.0
    ):
        self.config = config or ExperimentConfig()
        self.model_params = model_params or GrowthModelParameters()
        self.time_acceleration = time_acceleration
        
        # Create simulated device
        factory = SimulationFactory()
        device_config = BaseDeviceConfig()
        
        # Initialize experiment with device and growth model parameters
        self.device = factory.create_device(device_config, self.model_params)
        self.experiment = Experiment(
            device=self.device,
            config=self.config,
            name=f"simulation_{int(time.time())}"
        )
        
        # Initialize logger
        self.logger = SimulationLogger(output_dir="simulation_logs")
        
        # Control flags
        self._stop_event = Event()
        self._simulation_thread: Optional[Thread] = None
        
    def start(self):
        """Start simulation in background thread."""
        if self._simulation_thread is not None:
            raise RuntimeError("Simulation already running")
            
        self._stop_event.clear()
        self._simulation_thread = Thread(target=self._run_simulation)
        self._simulation_thread.start()
        
        self.logger.log_config({
            'experiment': self.config.__dict__,
            'growth_model': self.model_params.__dict__,
            'time_acceleration': self.time_acceleration
        })
        
    def stop(self):
        """Stop simulation."""
        if self._simulation_thread is None:
            return
            
        self._stop_event.set()
        self._simulation_thread.join()
        self._simulation_thread = None
        
    def _run_simulation(self):
        """Main simulation loop."""
        self.experiment.start()
        
        update_interval = self.config.measurement_interval_mins * 60  # seconds
        update_interval /= self.time_acceleration
        
        while not self._stop_event.is_set():
            try:
                # Update growth models
                self._update_growth_models()
                
                # Update experiment
                self.experiment.update()
                
                # Log status
                status = self.experiment.status
                for vial, data in status['cultures'].items():
                    print(f"Logging measurement for Vial {vial}: OD={data['od']:.3f}, Drug={data.get('drug_concentration', 0.0):.1f}")
                    self.logger.log_measurement(
                        vial=vial,
                        od=data['od'],
                        temperature=data.get('temperature', 25.0),
                        drug_concentration=data.get('drug_concentration', 0.0),
                        growth_rate=data.get('growth_rate'),
                        action=data.get('last_action')
                    )
                    
                if status['error']:
                    self.logger.log_event('error', {'message': status['error']})
                
                # Wait for next update
                time.sleep(update_interval)
                
            except Exception as e:
                print(f"Simulation error: {str(e)}")
                self.logger.log_event('error', {'message': str(e)})
                self.experiment.stop()
                break
                
    def _update_growth_models(self):
        """Update all growth models."""
        od_sensor = self.device._od_sensor
        for vial in range(1, self.config.device_config.n_vials + 1):
            model = od_sensor._growth_models[vial]
            model.update(
                timestep_mins=self.config.measurement_interval_mins / self.time_acceleration
            ) 

--- simulation/src/replifactory_simulation/simulation_factory.py ---
from replifactory_core.interfaces import (
    PumpInterface, ValveInterface, StirrerInterface,
    ODSensorInterface, ThermometerInterface
)
from replifactory_core.base_device import BaseDevice, BaseDeviceConfig
from replifactory_core.factory import DeviceComponentFactory

from .devices import (
    SimulatedPump, SimulatedValves, SimulatedStirrer,
    SimulatedODSensor, SimulatedThermometer
)


class SimulationFactory(DeviceComponentFactory):
    def create_pump(self, pump_number: int) -> PumpInterface:
        return SimulatedPump(pump_number=pump_number)
    
    def create_valves(self) -> ValveInterface:
        return SimulatedValves()
    
    def create_stirrer(self) -> StirrerInterface:
        return SimulatedStirrer()
    
    def create_od_sensor(self) -> ODSensorInterface:
        return SimulatedODSensor()
    
    def create_thermometer(self) -> ThermometerInterface:
        return SimulatedThermometer()


def create_simulated_device(config: BaseDeviceConfig = None) -> BaseDevice:
    if config is None:
        config = BaseDeviceConfig()
    
    factory = SimulationFactory()
    
    pumps = {
        1: factory.create_pump(1),  # Media
        2: factory.create_pump(2),  # Drug
        4: factory.create_pump(4)   # Waste
    }
    
    return BaseDevice(
        config=config,
        pumps=pumps,
        valves=factory.create_valves(),
        stirrer=factory.create_stirrer(),
        od_sensor=factory.create_od_sensor(),
        thermometer=factory.create_thermometer()
    )

--- simulation/tests/.gitkeep ---


--- simulation/tests/simple_test.py ---
import pytest
import numpy as np
from replifactory_core.base_device import BaseDeviceConfig
from replifactory_simulation.simulation_factory import create_simulated_device
from replifactory_core.interfaces import DeviceError, StirrerSpeed




@pytest.fixture
def device():
    return create_simulated_device()


def test_device_creation():
    device = create_simulated_device()
    assert device is not None
    
    # Check required components exist
    assert 1 in device._pumps  # Media pump
    assert 2 in device._pumps  # Drug pump
    assert 4 in device._pumps  # Waste pump
    assert device._valves is not None
    assert device._stirrer is not None
    assert device._od_sensor is not None
    assert device._thermometer is not None


def test_vial_measurements(device):
    # Test valid measurement
    measurements = device.measure_vial(1)
    assert measurements.od >= 0
    assert 20 <= measurements.temperature <= 45  # Reasonable temp range
    assert measurements.rpm is not None
    
    # Test invalid vial number
    with pytest.raises(ValueError):
        device.measure_vial(8)
    with pytest.raises(ValueError):
        device.measure_vial(0)


def test_dilution_operation(device):
    # Valid dilution
    device.make_dilution(1, media_volume=5.0, drug_volume=0.5)
    
    # Test volume limits
    with pytest.raises(ValueError):
        device.make_dilution(1, media_volume=50.0, drug_volume=0.5)  # Too much volume
        
    # Test invalid vial
    with pytest.raises(ValueError):
        device.make_dilution(8, media_volume=5.0, drug_volume=0.5)


def test_pump_behavior(device):
    pump = device._pumps[1]
    
    # Test pumping
    initial_volume = pump.pumped_volume
    test_volume = 5.0
    pump.pump(test_volume)
    assert pump.pumped_volume == initial_volume + test_volume
    assert not pump.is_pumping
    
    # Test concurrent pumping prevention
    with pytest.raises(DeviceError):
        pump.pump(1.0)
        pump.pump(1.0)  # Should fail - pump busy


def test_valve_operations(device):
    valves = device._valves
    
    # Test open/close
    valves.open(1)
    assert valves.is_open(1)
    valves.close(1)
    assert not valves.is_open(1)
    
    # Test close_all
    valves.open(1)
    valves.open(2)
    valves.close_all()
    assert not any(valves.is_open(v) for v in range(1, 8))


def test_stirrer_control(device):
    stirrer = device._stirrer
    
    # Test speed setting
    stirrer.set_speed(1, StirrerSpeed.HIGH)
    rpm = stirrer.measure_rpm(1)
    assert rpm > 0
    
    stirrer.set_speed(1, StirrerSpeed.STOPPED)
    rpm = stirrer.measure_rpm(1)
    assert rpm == 0
    
    # Test emergency stop
    stirrer.set_speed(1, StirrerSpeed.HIGH)
    stirrer.stop_all()
    rpm = stirrer.measure_rpm(1)
    assert rpm == 0


def test_od_sensor(device):
    sensor = device._od_sensor
    
    # Test OD measurement
    od, signal = sensor.measure_od(1)
    assert od >= 0
    assert signal > 0
    
    # Test blank measurement
    blank = sensor.measure_blank(1)
    assert blank > 0


def test_temperature_monitoring(device):
    temps = device._thermometer.measure_temperature()
    
    assert 'vials' in temps
    assert 'board' in temps
    assert 20 <= temps['vials'] <= 45
    assert 20 <= temps['board'] <= 45


def test_vial_status(device):
    status = device.vial_status
    
    # Check all vials present
    assert all(v in status for v in range(1, 8))
    
    # Check required measurements
    for v in range(1, 8):
        assert 'od' in status[v]
        assert 'temperature' in status[v]
        assert 'rpm' in status[v]


def test_emergency_stop(device):
    # Set up some activity
    device._valves.open(1)
    device._stirrer.set_speed(1, StirrerSpeed.HIGH)
    
    # Emergency stop
    device.emergency_stop()
    
    # Verify everything stopped
    assert not device._valves.is_open(1)
    assert device._stirrer.measure_rpm(1) == 0
    assert not any(pump.is_pumping for pump in device._pumps.values())


def test_growth_simulation(device):
    # Initial measurement
    m1 = device.measure_vial(1)
    initial_od = m1.od
    
    # Make dilution and verify OD decreases
    device.make_dilution(1, media_volume=5.0, drug_volume=0.0)
    m2 = device.measure_vial(1)
    assert m2.od < initial_od
    
    # Add drug and verify growth impact
    device.make_dilution(1, media_volume=0.0, drug_volume=5.0)
    m3 = device.measure_vial(1)
    status = device.vial_status

--- tools/gitkeep_dirs.py ---
import os

def add_gitkeep_to_empty_dirs(base_path):
    """Recursively add .gitkeep to every empty directory under the base path."""
    for root, dirs, files in os.walk(base_path):
        for directory in dirs:
            dir_path = os.path.join(root, directory)
            if not os.listdir(dir_path):  # Check if the directory is empty
                gitkeep_path = os.path.join(dir_path, '.gitkeep')
                with open(gitkeep_path, 'w') as f:
                    pass  # Create an empty .gitkeep file
                print(f"Added .gitkeep to: {dir_path}")

if __name__ == "__main__":
    base_path = os.getcwd()  # Change to the desired base path if needed
    add_gitkeep_to_empty_dirs(base_path)


--- ui/pyproject.toml ---


--- ui/tests/.gitkeep ---

