Repository: replifactory

File Tree:
└── .gitignore
└── README.md
└── core/pyproject.toml
└── core/src/replifactory_core/base_device.py
└── core/src/replifactory_core/interfaces.py
└── core/src/replifactory_core/parameters.py
└── core/src/replifactory_core/types.py
└── core/tests/.gitkeep
└── docs/developer-guide/.gitkeep
└── docs/index.md
└── docs/user-guide/.gitkeep
└── hardware/pyproject.toml
└── hardware/tests/.gitkeep
└── mkdocs.yml
└── nx.json
└── server/pyproject.toml
└── server/src/replifactory_server/.gitkeep
└── server/tests/.gitkeep
└── simulation/pyproject.toml
└── simulation/src/replifactory_simulation/.gitkeep
└── simulation/tests/.gitkeep
└── tools/gitkeep_dirs.py
└── ui/pyproject.toml
└── ui/tests/.gitkeep

File Contents:

--- .gitignore ---
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# PyPI configuration file
.pypirc


# Project-specific
misc/

--- README.md ---
# replifactory

--- core/pyproject.toml ---


--- core/src/replifactory_core/base_device.py ---
from dataclasses import dataclass
from typing import Dict, Optional

from .interfaces import (
    ExperimentDeviceInterface,
    PumpInterface,
    ValveInterface,
    StirrerInterface,
    ODSensorInterface,
    ThermometerInterface,
    VialMeasurements,
    DeviceError
)

from .parameters import *


@dataclass
class BaseDeviceConfig:
    """Configuration for BaseDevice.
    
    Attributes:
        n_vials: Number of vials in device
        max_volume_ml: Maximum vial volume in ml
        min_volume_ml: Minimum operating volume in ml
    """
    n_vials: int = 7
    max_volume_ml: float = 30.0
    min_volume_ml: float = 5.0


class BaseDevice(ExperimentDeviceInterface):
    """Base implementation of experiment device control.
    
    Coordinates multiple device components to perform experiment operations.
    All hardware-specific implementation is delegated to injected components.
    
    Args:
        config: Device configuration
        pumps: Dict mapping pump numbers to pump interfaces
        valves: Valve control interface
        stirrer: Stirrer control interface
        od_sensor: OD measurement interface
        thermometer: Temperature measurement interface
    """
    
    def __init__(
        self,
        config: BaseDeviceConfig,
        pumps: Dict[int, PumpInterface],
        valves: ValveInterface,
        stirrer: StirrerInterface,
        od_sensor: ODSensorInterface,
        thermometer: ThermometerInterface,
    ):
        self.config = config
        self._pumps = pumps
        self._valves = valves
        self._stirrer = stirrer
        self._od_sensor = od_sensor
        self._thermometer = thermometer
        
        # Validate configuration
        self._validate_components()

    def _validate_components(self) -> None:
        """Validate device configuration and components.
        
        Raises:
            ValueError: If configuration is invalid
            DeviceError: If components are missing or misconfigured
        """
        if not (1 <= self.config.n_vials <= 7):
            raise ValueError(f"Invalid number of vials: {self.config.n_vials}")
            
        required_pumps = {1, 2, 4}  # Media, drug, waste
        if not all(p in self._pumps for p in required_pumps):
            raise DeviceError(f"Missing required pumps: {required_pumps - set(self._pumps)}")

    def measure_vial(self, vial: int) -> VialMeasurements:
        """Get all measurements for a specific vial.
        
        Coordinates multiple measurements while handling stirrer speed.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            VialMeasurements with all available data
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If critical measurements fail
        """
        if not 1 <= vial <= self.config.n_vials:
            raise ValueError(f"Invalid vial number: {vial}")
            
        try:
            # Set stirrer to measurement speed
            self._stirrer.set_speed(vial, "low")
            
            # Take measurements
            od, signal = self._od_sensor.measure_od(vial)
            temp = self._thermometer.measure_temperature()['vials']
            rpm = self._stirrer.measure_rpm(vial)
            
            # Restore stirrer speed
            self._stirrer.set_speed(vial, "high")
            
            return VialMeasurements(
                od=od,
                temperature=temp,
                rpm=rpm
            )
            
        except Exception as e:
            # Ensure stirrer restored on error
            self._stirrer.set_speed(vial, "high")
            raise DeviceError(f"Measurement failed: {str(e)}")

    def make_dilution(self, vial: int, media_volume: float, drug_volume: float) -> None:
        """Perform dilution operation on specific vial.
        
        Args:
            vial: Vial number (1-7)
            media_volume: Volume of fresh media to add in ml
            drug_volume: Volume of drug solution to add in ml
            
        Raises:
            ValueError: If parameters invalid
            DeviceError: If operation fails
        """
        if not 1 <= vial <= self.config.n_vials:
            raise ValueError(f"Invalid vial number: {vial}")
            
        # Validate volumes
        total_volume = media_volume + drug_volume
        if total_volume > self.config.max_volume_ml:
            raise ValueError(f"Total volume {total_volume} exceeds maximum {self.config.max_volume_ml}")
            
        try:
            # Remove waste volume
            self._valves.open(vial)
            self._pumps[4].pump(total_volume)  # Waste pump
            
            # Add fresh media
            if media_volume > 0:
                self._pumps[1].pump(media_volume)  # Media pump
                
            # Add drug
            if drug_volume > 0:
                self._pumps[2].pump(drug_volume)  # Drug pump
                
        except Exception as e:
            self.emergency_stop()
            raise DeviceError(f"Dilution failed: {str(e)}")
            
        finally:
            self._valves.close(vial)

    def emergency_stop(self) -> None:
        """Emergency stop all device operations."""
        try:
            # Stop all moving parts
            for pump in self._pumps.values():
                pump.stop()
            self._stirrer.stop_all()
            
            # Close all valves
            self._valves.close_all()
            
        except Exception as e:
            # Log but don't raise - must try all stop operations
            print(f"Error during emergency stop: {str(e)}")

    @property
    def vial_status(self) -> Dict[int, Dict[str, float]]:
        """Get current status of all vials."""
        status = {}
        for vial in range(1, self.config.n_vials + 1):
            try:
                measurements = self.measure_vial(vial)
                status[vial] = {
                    'od': measurements.od,
                    'temperature': measurements.temperature,
                    'rpm': measurements.rpm if measurements.rpm else 0.0
                }
            except Exception as e:
                # Include error indication in status
                status[vial] = {
                    'od': -1.0,
                    'temperature': -1.0,
                    'rpm': -1.0,
                    'error': str(e)
                }
        return status

--- core/src/replifactory_core/interfaces.py ---
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Dict, Optional, Tuple, List


class DeviceError(Exception):
    """Base exception for device-related errors."""
    pass


class StirrerSpeed(str, Enum):
    """Enumeration of valid stirrer speeds.
    
    STOPPED: Motor off
    LOW: Low speed for measurement
    HIGH: Normal operating speed
    """
    STOPPED = "stopped"
    LOW = "low"
    HIGH = "high"


class PumpInterface(ABC):
    """Interface for controlling fluid pumps in the device.
    
    Provides high-level control of pumping operations while abstracting away
    hardware details like stepper motors or peristaltic mechanisms.
    
    A pump must maintain accurate volume tracking and provide immediate
    stop capability for safety.
    
    Typical usage:
        pump.pump(5.0)  # Pump 5ml
        if pump.is_pumping:
            pump.stop()  # Emergency stop
    """
    
    @abstractmethod
    def pump(self, volume_ml: float) -> None:
        """Pump a specific volume of fluid.
        
        Args:
            volume_ml: Volume to pump in milliliters. Positive values pump forward,
                      negative values pump in reverse if supported.
        
        Raises:
            ValueError: If volume exceeds pump parameters
            DeviceError: If pump operation fails
        
        Note:
            Method should block until pumping is complete unless stopped.
        """
        pass
    
    @abstractmethod
    def stop(self) -> None:
        """Immediately stop the pump.
        
        Emergency stop that halts the pump as quickly as possible without
        regard for completing the current operation.
        
        The pumped_volume property should reflect the actual delivered volume.
        
        Raises:
            DeviceError: If pump fails to stop
        """
        pass

    @property
    @abstractmethod
    def is_pumping(self) -> bool:
        """Check if pump is currently active.
        
        Returns:
            bool: True if pump is in operation, False if idle
            
        Note: 
            Should return True from the moment pump() is called until 
            the operation completes or is stopped.
        """
        pass

    @property
    @abstractmethod
    def pumped_volume(self) -> float:
        """Get total volume pumped since last reset.
        
        Returns:
            float: Cumulative volume in milliliters, including partial volumes
                  from stopped operations
                  
        Note:
            Tracking should continue across multiple pump operations until reset.
        """
        pass


class ValveInterface(ABC):
    """Interface for controlling liquid flow valves.
    
    Controls individual solenoid valves that direct fluid flow in the device.
    Each valve has a unique number and binary open/closed state.
    
    Valves are critical for fluid routing and provide safety isolation.
    All implementations must ensure reliable state reporting and 
    fail-closed behavior.
    
    Typical usage:
        valve.open(1)   # Open valve 1
        if valve.is_open(1):
            valve.close(1)
    """
    
    @abstractmethod
    def open(self, valve_number: int) -> None:
        """Open a specific valve.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Raises:
            ValueError: If valve_number is invalid (not 1-7)
            DeviceError: If valve fails to open or verify state
            
        Note:
            Method should block until valve is fully open and verified.
        """
        pass

    @abstractmethod
    def close(self, valve_number: int) -> None:
        """Close a specific valve.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Raises:
            ValueError: If valve_number is invalid
            DeviceError: If valve fails to close or verify state
            
        Note:
            Method must ensure valve is fully closed before returning.
            Should never fail to at least attempt closure for safety.
        """
        pass

    @abstractmethod
    def is_open(self, valve_number: int) -> bool:
        """Check if specific valve is open.
        
        Args:
            valve_number: Identifier of the valve (1-7)
            
        Returns:
            bool: True if valve is confirmed open, False if confirmed closed
            
        Raises:
            ValueError: If valve_number is invalid
            DeviceError: If valve state cannot be determined
            
        Note:
            Must return accurate state - if state cannot be verified,
            should raise DeviceError rather than guess.
        """
        pass

    @abstractmethod
    def close_all(self) -> None:
        """Close all valves immediately.
        
        Critical safety method - must attempt to close all valves even if
        some operations fail. Should be called in any error condition.
        
        Raises:
            DeviceError: If any valve fails to close. Error should include
                        information about which valves failed.
                        
        Note:
            Should make best effort to close all valves even after errors.
        """
        pass


class StirrerInterface(ABC):
    """Interface for controlling magnetic stirrers.
    
    Manages the stirring motors that mix cultures via magnetic stir bars.
    Supports variable speeds and rotation monitoring.
    
    Speed control is critical for:
    - Proper culture mixing
    - Accurate OD measurements (requires LOW speed)
    - Prevention of vortexing (speed limits)
    
    Implementation must ensure smooth speed transitions and
    accurate RPM reporting when available.
    
    Typical usage:
        stirrer.set_speed(1, StirrerSpeed.HIGH)  # Normal operation
        rpm = stirrer.measure_rpm(1)             # Check actual speed
        stirrer.set_speed(1, StirrerSpeed.LOW)   # Prepare for measurement
    """
    
    @abstractmethod
    def set_speed(self, vial: int, speed: StirrerSpeed) -> None:
        """Set stirrer speed for a specific vial.
        
        Args:
            vial: Vial number (1-7)
            speed: Desired stirring speed setting
            
        Raises:
            ValueError: If vial number invalid or speed not in StirrerSpeed
            DeviceError: If speed cannot be set or verified
            
        Note:
            Should transition smoothly between speeds to avoid splashing.
            Must verify speed change before returning.
        """
        pass
    
    @abstractmethod
    def measure_rpm(self, vial: int) -> float:
        """Measure current RPM for specific vial.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            float: Current stirring speed in rotations per minute
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If RPM cannot be measured
            
        Note:
            May return approximate RPM if exact measurement not possible.
            Should indicate measurement quality through error bounds.
        """
        pass

    @abstractmethod
    def stop_all(self) -> None:
        """Emergency stop all stirrers.
        
        Immediately stops all stirring motors. Used in emergency situations
        or during shutdown.
        
        Raises:
            DeviceError: If any stirrer fails to stop. Should still attempt
                        to stop all stirrers even after an error.
                        
        Note:
            Must attempt to stop all stirrers regardless of errors.
            Critical safety method.
        """
        pass


class ODSensorInterface(ABC):
    """Interface for optical density measurement system.
    
    Manages laser-based optical density measurements for monitoring bacterial growth.
    Coordinates laser control and photodiode readings to produce accurate OD values.
    
    Key responsibilities:
    - Accurate OD measurements
    - Blank calibration
    - Signal quality monitoring
    - Laser safety management
    
    Implementation must ensure:
    - Laser safety interlocks
    - Proper measurement timing
    - Signal stability checking
    - Background light compensation
    
    Typical usage:
        od, signal = sensor.measure_od(1)  # Get current OD
        blank = sensor.measure_blank(1)    # Calibration measurement
    """
    
    @abstractmethod
    def measure_od(self, vial: int, parameters: Optional[ODParameters] = None) -> Tuple[float, float]:
        """Measure optical density for specific vial.
        
        Performs a complete OD measurement cycle:
        1. Set stirrer to measurement speed
        2. Turn on laser
        3. Take photodiode reading
        4. Turn off laser
        5. Restore stirrer speed
        
        Args:
            vial: Vial number (1-7)
            parameters: Optional measurement parameters. Uses defaults if None.
            
        Returns:
            Tuple[float, float]: (od_value, signal_strength)
                od_value: Calculated optical density (relative to blank)
                signal_strength: Raw photodiode signal in millivolts
                
        Raises:
            ValueError: If vial number invalid
            DeviceError: If measurement fails (laser, photodiode, or signal quality)
            
        Note:
            Returns both OD and raw signal to allow signal quality assessment.
            Should verify signal stability before returning.
        """
        pass

    @abstractmethod
    def measure_blank(self, vial: int) -> float:
        """Measure blank/reference value for calibration.
        
        Takes reference measurement of clear media for OD calculation baseline.
        Must be called on each vial before experiment starts.
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            float: Blank reading in millivolts
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If measurement fails or signal unstable
            
        Note:
            Should take multiple readings and verify stability.
            Critical for accurate OD measurements.
        """
        pass


class ThermometerInterface(ABC):
    """Interface for temperature monitoring system.
    
    Manages temperature sensors for both culture vials and control board.
    Temperature monitoring is critical for:
    - Culture growth conditions
    - Hardware protection
    - Safety cutoffs
    
    Implementation must provide reliable temperature data and
    proper error handling for sensor failures.
    
    Typical usage:
        temps = thermometer.measure_temperature()
        vial_temp = temps['vials']
        board_temp = temps['board']
    """
    
    @abstractmethod
    def measure_temperature(self) -> Dict[str, float]:
        """Measure all system temperatures.
        
        Returns:
            Dict[str, float]: Temperature readings in Celsius
                'vials': Average temperature of vial array
                'board': Control board temperature
                
        Raises:
            DeviceError: If temperature measurements fail or are out of range
            
        Note:
            Should include validity checks on temperature values.
            Must handle partial sensor failures gracefully.
        """
        pass


class ExperimentDeviceInterface(ABC):
    """High-level interface for experiment control.
    
    Provides experiment-focused operations that coordinate multiple device
    components. This is the primary interface used by experiment control logic.
    
    Responsible for:
    - Measurement coordination
    - Dilution operations
    - Status monitoring
    - Emergency handling
    
    Implementation must ensure:
    - Operation atomicity
    - Error recovery
    - Data consistency
    - Safe state management
    
    Typical usage:
        measurements = device.measure_vial(1)
        device.make_dilution(1, media_ml=5.0, drug_ml=0.5)
        status = device.vial_status
    """
    
    @abstractmethod
    def measure_vial(self, vial: int) -> VialMeasurements:
        """Get all measurements for a specific vial.
        
        Performs a complete measurement cycle:
        1. Temperature reading
        2. RPM measurement if available
        3. OD measurement
        4. Growth rate calculation if possible
        
        Args:
            vial: Vial number (1-7)
            
        Returns:
            VialMeasurements: Combined measurements from vial
            
        Raises:
            ValueError: If vial number invalid
            DeviceError: If critical measurements fail
            
        Note:
            Should complete all possible measurements even if some fail.
            Critical measurements (OD) failure causes error.
        """
        pass
    
    @abstractmethod
    def make_dilution(self, vial: int, media_volume: float, drug_volume: float) -> None:
        """Perform dilution operation on specific vial.
        
        Executes complete dilution sequence:
        1. Verify volumes and vial state
        2. Remove waste volume
        3. Add fresh media
        4. Add drug solution
        5. Verify operation completion
        
        Args:
            vial: Vial number (1-7)
            media_volume: Volume of fresh media to add in ml
            drug_volume: Volume of drug solution to add in ml
            
        Raises:
            ValueError: If vial number or volumes invalid
            DeviceError: If dilution operation fails
            
        Note:
            Operation must be atomic - should revert to safe state on error.
            Must verify all steps complete successfully.
        """
        pass

    @abstractmethod
    def emergency_stop(self) -> None:
        """Emergency stop all device operations.
        
        Immediately stops all device components and sets system to safe state:
        1. Stop all pumps
        2. Close all valves
        3. Stop all stirrers
        4. Turn off all lasers
        5. Set status LEDs to error state
        
        Should be called in response to:
        - Critical errors
        - Safety interlock triggers
        - User emergency stop
        - Power issues
        
        Note:
            Most critical safety method - must be extremely reliable.
            Should attempt all steps even if some fail.
            Must log all actions and failures.
        """
        pass

    @property
    @abstractmethod
    def vial_status(self) -> Dict[int, Dict[str, float]]:
        """Get current status of all vials.
        
        Provides snapshot of system state including:
        - OD readings
        - Temperatures
        - Stirrer speeds
        - Growth rates
        
        Returns:
            Dict[int, Dict[str, float]]: Status data
                Keys: vial numbers (1-7)
                Values: dict with measurement values
                    'od': Current optical density
                    'temperature': Current temperature
                    'rpm': Current stirrer speed if available
                    'growth_rate': Current growth rate if available
        
        Note:
            Should return best available data even if some readings fail.
            Must indicate missing/failed measurements appropriately.
        """
        pass

--- core/src/replifactory_core/parameters.py ---
from dataclasses import dataclass
from enum import Enum
from typing import Optional

@dataclass
class PumpParameters:
    """Parameters defining pump operational characteristics.
    
    Attributes:
        max_volume_ml: Maximum volume in ml that can be pumped in one operation
        min_volume_ml: Minimum volume in ml that can be reliably pumped
        flow_rate_mlps: Flow rate in milliliters per second
    
    Note:
        These parameters are used for both real and simulated pumps to ensure
        consistent behavior across implementations.
    """
    max_volume_ml: float 
    min_volume_ml: float
    flow_rate_mlps: float  


@dataclass
class ODParameters:
    """Parameters for optical density measurements.
    
    These settings control the sensitivity and accuracy of OD readings.
    
    Attributes:
        gain: Amplification factor for photodiode signal (1, 2, 4, or 8)
            Higher gain for low OD samples, lower for high OD
        bitrate: ADC resolution in bits (12, 14, 16, or 18)
            Higher bitrate gives better precision but slower readings
        continuous_conversion: If True, ADC runs continuously
        samples_to_average: Number of samples to take and average
    """
    gain: int = 8
    bitrate: int = 16
    continuous_conversion: bool = False
    samples_to_average: int = 3


@dataclass
class LaserParameters:
    """Parameters for laser operation.
    
    Controls laser behavior during measurements.
    
    Attributes:
        warmup_time_ms: Time to wait after laser on before reading
        measurement_time_ms: Duration of measurement
        cooldown_time_ms: Time to wait between measurements
    """
    warmup_time_ms: int = 20
    measurement_time_ms: int = 100
    cooldown_time_ms: int = 50


@dataclass
class StirrerParameters:
    """Parameters for stirrer operation.
    
    Defines stirring behavior for different modes.
    
    Attributes:
        high_speed_duty_cycle: PWM duty cycle for normal operation (0-1)
        low_speed_duty_cycle: PWM duty cycle for measurement (0-1)
        acceleration_time_ms: Time to reach target speed
    """
    high_speed_duty_cycle: float = 0.8
    low_speed_duty_cycle: float = 0.3
    acceleration_time_ms: int = 100


@dataclass
class MeasurementParameters:
    """Combined parameters for all measurement operations.
    
    Collects all measurement-related parameters in one place.
    
    Attributes:
        od: Optical density measurement parameters
        laser: Laser operation parameters
        stirrer: Stirrer behavior parameters
        wait_for_steady_state: If True, verify readings are stable
        max_retries: Number of measurement retries on error
    """
    od: ODParameters = ODParameters()
    laser: LaserParameters = LaserParameters()
    stirrer: StirrerParameters = StirrerParameters()
    wait_for_steady_state: bool = True
    max_retries: int = 3

--- core/src/replifactory_core/types.py ---


--- core/tests/.gitkeep ---


--- docs/developer-guide/.gitkeep ---


--- docs/index.md ---


--- docs/user-guide/.gitkeep ---


--- hardware/pyproject.toml ---


--- hardware/tests/.gitkeep ---


--- mkdocs.yml ---


--- nx.json ---


--- server/pyproject.toml ---


--- server/src/replifactory_server/.gitkeep ---


--- server/tests/.gitkeep ---


--- simulation/pyproject.toml ---


--- simulation/src/replifactory_simulation/.gitkeep ---


--- simulation/tests/.gitkeep ---


--- tools/gitkeep_dirs.py ---
import os

def add_gitkeep_to_empty_dirs(base_path):
    """Recursively add .gitkeep to every empty directory under the base path."""
    for root, dirs, files in os.walk(base_path):
        for directory in dirs:
            dir_path = os.path.join(root, directory)
            if not os.listdir(dir_path):  # Check if the directory is empty
                gitkeep_path = os.path.join(dir_path, '.gitkeep')
                with open(gitkeep_path, 'w') as f:
                    pass  # Create an empty .gitkeep file
                print(f"Added .gitkeep to: {dir_path}")

if __name__ == "__main__":
    base_path = os.getcwd()  # Change to the desired base path if needed
    add_gitkeep_to_empty_dirs(base_path)


--- ui/pyproject.toml ---


--- ui/tests/.gitkeep ---

